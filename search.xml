<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gRPC的大消息传输]]></title>
    <url>%2F2018%2F08%2F06%2Flarge-messages-with-grpc%2F</url>
    <content type="text"><![CDATA[概述使用gRPC的一个问题是，它的默认最大消息大小默认被设置为4MB，那么当数据量太大时该怎么办？ options可以通过在创建Server的时候，配置相关的参数来扩大限制最小消息大小的值。 1s := grpc.NewServer(grpc.MaxRecvMsgSize(size), grpc.MaxSendMsgSize(size)) MaxRecvMsgSize和MaxSendMsgSize分别设置服务器可以接收的最大消息大小和可以发送的最大消息大小（以字节为单位）。不设置的话默认都是4MB。 虽然可以配置，但这种行为是一种滑坡谬误，可能会导致不断修改增加服务端客户端最大消息大小，而且每次请求不一定都需要全部的数据，会导致很多性能和资源上的浪费。 chunk自然地将数据分成更小的块并使用gRPC流方法（stream）对其进行流式传输是一个不错的选择。 首先一个proto，是一个返回流式消息类型的rpc service。 12345678910111213syntax = &quot;proto3&quot;;package pb;service Chunker &#123; rpc Chunker(Empty) returns (stream Chunk) &#123;&#125;&#125;message Empty&#123;&#125;message Chunk &#123; bytes chunk = 1;&#125; 实现server的Chunker逻辑。流式消息的大小设置为64KB。 12345678910111213141516171819const chunkSize = 64 * 1024type chunkerSrv []bytefunc (c chunkerSrv) Chunker(_ *pb.Empty, srv pb.Chunker_ChunkerServer) error &#123; chunk := &amp;pb.Chunk&#123;&#125; n := len(c) for cur := 0; cur &lt; n; cur += chunkSize &#123; if cur+chunkSize &gt; n &#123; chunk.Chunk = c[cur:n] &#125; else &#123; chunk.Chunk = c[cur : cur+chunkSize] &#125; if err := srv.Send(chunk); err != nil &#123; return err &#125; &#125; return nil&#125; 然后把gRPC服务端运行起来，使用随机填充128M的数据来方便测试。123456789101112func main() &#123; listen, err := net.Listen("tcp", ":8888") if err != nil &#123; log.Fatal(err) &#125; s := grpc.NewServer() blob := make([]byte, 128*1024*1024) // 128M rand.Read(blob) pb.RegisterChunkerServer(s, chunkerSrv(blob)) log.Println("serving on localhost:8888") log.Fatal(s.Serve(listen))&#125; 编写个客户端请求一下。 123456789101112131415161718192021222324func main() &#123; conn, err := grpc.Dial("localhost:8888", grpc.WithInsecure()) if err != nil &#123; log.Fatal(err) &#125; client := pb.NewChunkerClient(conn) stream, err := client.Chunker(context.Background(), &amp;pb.Empty&#123;&#125;) if err != nil &#123; log.Fatal(err) &#125; var blob []byte for &#123; c, err := stream.Recv() if err != nil &#123; if err == io.EOF &#123; log.Printf("Transfer of %d bytes successful", len(blob)) // Transfer of 134217728 bytes successful return &#125; log.Fatal(err) &#125; blob = append(blob, c.Chunk...)&#125; 使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样客户端自己再拼接成完整的数据，无论多少数据都可以不用修改配置。 完整代码 range在数据量大的情况，不是每次都需要请求全量的数据。基于之上可以借鉴http的range协议来分片的取获取资源。同样的在Chunker的proto基础上修改，在请求的时候能传入零个（代表全部获取）或多个Range来分片获取资源。 1234567891011121314151617181920syntax = &quot;proto3&quot;;package pb;service RangeChunker &#123; rpc Range(Res) returns (stream Chunk) &#123;&#125;&#125;message Res &#123; repeated Range r = 1;&#125;message Range &#123; int32 start = 1; int32 stop = 2;&#125;message Chunk &#123; bytes chunk = 1;&#125; 服务端的实现主要是Range的解析，这里实现和http的range类似，使用0-99代表前100字节而不是0-100，并简化了很多，比如只保留了stop设置-1时代表最后一个字节，其他的负数操作都没有实现。需要的话可以自行修改rangeLimit。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const chunkSize = 64 * 1024type chunkerSrv []bytefunc (c chunkerSrv) Range(r *pb.Res, srv pb.RangeChunker_RangeServer) error &#123; chunk := &amp;pb.Chunk&#123;&#125; ranges := c.parseRanges(r) for _, rr := range ranges &#123; start, stop := rr[0], rr[1] for cur := start; cur &lt; stop; cur += chunkSize &#123; if cur+chunkSize &gt; stop &#123; chunk.Chunk = c[cur:stop] &#125; else &#123; chunk.Chunk = c[cur : cur+chunkSize] &#125; if err := srv.Send(chunk); err != nil &#123; return err &#125; &#125; &#125; return nil&#125;func (c chunkerSrv) parseRanges(r *pb.Res) [][2]int &#123; n := len(c) ranges := [][2]int&#123;&#125; rs := r.GetR() if len(rs) == 0 &#123; return [][2]int&#123;[2]int&#123;0, n&#125;&#125; &#125; for _, rr := range rs &#123; start, stop := rangeLimit(rr, n) if start == -1 &#123; return nil &#125; ranges = append(ranges, [2]int&#123;start, stop&#125;) &#125; return ranges&#125;func rangeLimit(r *pb.Range, llen int) (int, int) &#123; start, stop := int(r.Start), int(r.Stop)+1 if stop &gt; llen || stop == 0 &#123; stop = llen &#125; if start &lt; 0 || stop &lt; 0 || start &gt;= stop &#123; return -1, -1 &#125; return start, stop&#125; 客户端请求也很简单。 1234567stream, err := client.Range(context.Background(), &amp;pb.Res&#123; R: []*pb.Range&#123; &#123;0, 99&#125;, &#123;100, 199&#125;, &#123;200, -1&#125;, &#125;,&#125;) 完整代码 这样我们就可以只请求数据的某个部分，基于此之上还可以并行请求，断点续传等。]]></content>
      <categories>
        <category>grpc技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go与json]]></title>
    <url>%2F2018%2F07%2F30%2Fgo-and-json%2F</url>
    <content type="text"><![CDATA[概述日常开发中经常要在json对象与Go struct之间相互转换。由于Go是一个静态类型的语言，没办法像动态语言那么方便的序列化反序列化json，特别是json的来源不受控的时候。虽然可以使用map[string]interface{}表示动态类型，但是导致非常难看和难以维护的代码。本篇试着使用一些小技巧让序列化json变得更优雅。 动态的json假定一个场景邮件Envelope，不同的邮件类型的msg字段拥有不一样的结构。比如如下两个邮件json对象的msg字段的结构是不一样的。 1234567&#123; "type": "sound", "msg": &#123; "description": "dynamite", "authority": "the Bruce Dickinson" &#125;&#125; 123456&#123; "type": "cowbell", "msg": &#123; "more": true &#125;&#125; 序列化先定义一些基本类型，使用interface{}来包含不同的数据结构来序列化成不同类型的邮件json。12345678910111213type Envelope struct &#123; Type string `json:"type"` Msg interface&#123;&#125; `json:"msg"`&#125;type Sound struct &#123; Description string `json:"description"` Authority string `json:"authority"`&#125;type Cowbell struct &#123; More bool `json:"more"`&#125; 试着运行一下：1234567891011121314151617181920212223242526s := Envelope&#123; Type: "sound", Msg: &amp;Sound&#123; Description: "dynamite", Authority: "the Bruce Dickinson", &#125;,&#125;buf, err := json.Marshal(s)if err != nil &#123; log.Fatal(err)&#125;fmt.Printf("%s\n", buf) // &#123;"type":"sound","msg":&#123;"description":"dynamite","authority":"the Bruce Dickinson"&#125;&#125;c := Envelope&#123; Type: "cowbell", Msg: &amp;Cowbell&#123; More: true, &#125;,&#125;buf, err = json.Marshal(c)if err != nil &#123; log.Fatal(err)&#125;fmt.Printf("%s\n", buf) // &#123;"type":"cowbell","msg":&#123;"more":true&#125;&#125; 没有什么特殊的。完整代码 反序列化当我们要反序列化json到Envelope，那么使用map[string]interface{}来解析msg是很多人喜欢的做法，但是这不是很优雅，而且很容易出错。1234567891011121314151617input := `&#123; "type": "sound", "msg": &#123; "description": "dynamite", "authority": "the Bruce Dickinson" &#125;&#125;`var env Envelopeif err := json.Unmarshal([]byte(input), &amp;env); err != nil &#123; log.Fatal(err)&#125;desc := env.Msg.(map[string]interface&#123;&#125;)["description"].(string)fmt.Println(desc)// dynamite 使用RawMessagejson.RawMessage是一个有用的类型，可以让你推迟反序列化，其实它只是将原始数据存储为[]byte。1234type Envelope struct &#123; Type string `json:"type"` Msg *json.RawMessage `json:"msg"`&#125; 这样可以明确地控制json的反序列话，并且因为延迟，我们要用到有不同类型分支的数据才去处理。但是序列化的时候要先明确数据结构，如果独立EnvelopeIn和EnvelopeOut分别用来序列化和反序列化，也不好，其实我们可以结合json.RawMessage和interface{}来使用，不必修改Envelope的结构。 12345678910111213141516171819var msg json.RawMessageenv := Envelope&#123; Msg: &amp;msg,&#125;if err := json.Unmarshal([]byte(input), &amp;env); err != nil &#123; log.Fatal(err)&#125;switch env.Type &#123;case "sound": var s Sound if err := json.Unmarshal(msg, &amp;s); err != nil &#123; log.Fatal(err) &#125; desc := s.Description fmt.Println(desc) // dynamitedefault: log.Fatalf("unknown message type: %q", env.Type)&#125; 完整代码 拆分和组合尽管期望json格式比较规范，有分支字段放在一个键下面，但是有时还是会从外部接受到不好的数据格式，比如数据都在顶层。我们可以使用拆分分别使用这些值，也可以如注释组合成一个大的struct来处理。 123456789101112131415161718192021222324252627282930313233343536input := `&#123; "type": "sound", "description": "dynamite", "authority": "the Bruce Dickinson"&#125;`var env Envelopebuf := []byte(input)if err := json.Unmarshal(buf, &amp;env); err != nil &#123; log.Fatal(err)&#125;switch env.Type &#123;case "sound": var env Envelope var s Sound if err := json.Unmarshal(buf, &amp;struct &#123; *Envelope *Sound &#125;&#123;&amp;env, &amp;s&#125;); err != nil &#123; log.Fatal(err) &#125; // s := struct &#123; // *Envelope // *Sound // &#125;&#123;&#125; // if err := json.Unmarshal(buf, &amp;s); err != nil &#123; // log.Fatal(err) // &#125; desc := s.Description fmt.Println(desc) // dynamitedefault: log.Fatalf("unknown message type: %q", env.Type)&#125; 完整代码 忽略字段当要序列化Sound的时候想要忽略Authority字段，可以使用组合的方法覆盖掉原有的参数属性：123456type omit *struct&#123;&#125;type OmitSound struct &#123; *Sound Authority omit `json:"authority,omitempty"`&#125; 这里的技巧是不设置OmitSound的Authority字段，因为它是一个指针类型，默认值为nil，它将被省略（因为omitempty）。12345678910111213141516171819s := &amp;Sound&#123; Description: "dynamite", Authority: "the Bruce Dickinson",&#125;buf, err := json.Marshal(OmitSound&#123; Sound: s,&#125;)// buf, err := json.Marshal(struct &#123;// *Sound// Authority bool `json:"authority,omitempty"`// &#125;&#123;// Sound: s,// &#125;)if err != nil &#123; log.Fatal(err)&#125;fmt.Printf("%s\n", buf)// &#123;"description":"dynamite"&#125; 也可以像注释中之间使用匿名struct，忽略的字段可以使用*struct{}甚至bool或int，使用哪种内置类型无关紧要，只要它具有omitempty标记识别的零值即可。 完整代码 添加额外的字段添加字段比省略更简单。1234567891011121314151617s := &amp;Sound&#123; Description: "dynamite", Authority: "the Bruce Dickinson",&#125;buf, err := json.Marshal(struct &#123; *Sound Other string `json:"other"`&#125;&#123; Sound: s, Other: "other",&#125;)if err != nil &#123; log.Fatal(err)&#125;fmt.Printf("%s\n", buf)// &#123;"description":"dynamite","authority":"the Bruce Dickinson","other":"other"&#125; 完整代码 重命名字段重命名其实是忽略和添加额外字段的组合。请注意，仅当要重命名大struct中的一个或两个字段时，这才是实用的。当重命名所有（大部分）字段时，通常创建一个新struct会比较合适。 12345678910111213141516171819202122s := &amp;Sound&#123; Description: "dynamite", Authority: "the Bruce Dickinson",&#125;buf, err := json.Marshal(struct &#123; *Sound // omit keys OmitAuthority string `json:"authority,omitempty"` // add keys Authority string `json:"author"`&#125;&#123; Sound: s, Authority: s.Authority,&#125;)if err != nil &#123; log.Fatal(err)&#125;fmt.Printf("%s\n", buf)// &#123;"description":"dynamite","author":"the Bruce Dickinson"&#125; 完整代码]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好WebAssembly]]></title>
    <url>%2F2018%2F06%2F28%2Fhello-webassembly%2F</url>
    <content type="text"><![CDATA[概述上篇介绍了如何成功执行了Go编译的第一个WebAssembly(以下简称wasm)二进制文件，接着进一步测试下Go的wasm的能实现的功能。 从Go调用JSGo的标准库有一个新的包syscall/js，先看下js.go文件。里面定义了个新的类型js.Value，它表示一个JavaScript值。它提供了一个简单的API来操纵任何类型的JavaScript值并与之交互： js.Value.Get()和js.Value.Set()检索并设置Object值的属性 js.Value.Index()和js.Value.SetIndex()检索并设置Array值中的值 js.Value.Call()在一个Object值上调用一个方法 js.Value.Invoke()调用一个函数值 js.Value.New()在代表JS类型的引用上调用new运算符 在相应的Go类型中检索JavaScript值的其他方法（如js.Value.Int()或js.Value.Bool()） 一个js.ValueOf()函数，它接受任何Go基本类型并返回相应的js.Value。 最后是一些有趣的变量： js.Undefined与js的undefined对应的js.Value js.Null与js的null对应的js.Value js.Global允许访问js全局范围的js.Value 尝试调用下js的window.alert()将消息其显示在对话框中，而不是发送到console。 由于在浏览器中，global就是window，从global中检索alert()，于是有了一个alert类型的js.Value变量，它是对js的window.alert的引用，在其上使用js.Value.Invoke()。可以发现在将参数传递给Invoke之前不需要调用js.ValueOf()，它接受interface{}参数，并通过调用ValueOf去运行。 12345678910package mainimport ( "syscall/js")func main() &#123; alert := js.Global().Get("alert") alert.Invoke("Hello wasm!")&#125; 现在，当点击按钮时，会弹出一条包含Hello wasm!消息的对话框。 完整代码 从JS调用Go如上从Go调用js非常简单，接着看callback.go文件。里面定义了一个新的js.Callback类型，它代表一个Go的func包装以便用作js回调。一个js.NewCallback()函数，它接受一个js.Value切片（并且不返回任何内容）并返回一个js.Callback。并提供一些机制来管理活动回调，以及一个js.Callback.Close()函数，当不再使用回调时必须调用它来释放相应资源。另外还有一个js.NewEventCallback()函数来接受js事件。 先试着做一些简单的事情，从js端触发Go的fmt.Println。 当前执行wasm二进制文件的run()函数如下所示，需要在wasm_exec.html中进行一些调整，让它能够从Go接收回调并调用它。 1234async function run() &#123; console.clear() await go.run(ist) inst = await WebAssembly.instantiate(mod, go.importObject) 它启动wasm二进制文件并等待它终止，然后重新实例化它以便下次运行。添加一个新的函数，它将接收并存储Go回调，并在完成后立即解析Promise： 1234567let printMessagelet printMessageReceivedlet resolvePrintMessageReceivedfunction setPrintMessage(callback) &#123; printMessage = callback resolvePrintMessageReceived()&#125; 现在调整run()函数以使用回调： 12345678910async function run() &#123; console.clear() printMessageReceived = new Promise(resolve =&gt; &#123; resolvePrintMessageReceived = resolve &#125;) const run = go.run(inst) await printMessageReceived printMessage('Hello Wasm!') await run inst = await WebAssembly.instantiate(mod, go.importObject) 现在Go部分需要创建回调，将其发送给js端并等待它被调用。需要一个channel来通知回调被调用了，然后编写实际的printMessage()``func： 1234567var done = make(chan struct&#123;&#125;)func printMessage(args []js.Value) &#123; message := args[0].String() fmt.Println(message) done &lt;- struct&#123;&#125;&#123;&#125;&#125; 正如所看到的，参数是在js.Value的切片中接收到的，在第一个元素上调用js.Value.String()转化为Go的string来获取message。现在可以在回调中包装这个func，然后调用js的setPrintMessage()函数，就像调用window.alert()时一样，最后就是等待回调被调用，这个很重要，因为回调是在goroutine中执行的，因此主goroutine必须等待回调被调用，否则wasm二进制会提前终止。 1234567callback := js.NewCallback(printMessage)defer callback.Close()setPrintMessage := js.Global().Get("setPrintMessage")setPrintMessage.Invoke(callback)&lt;-done 完整的Go程序应如下所示： 123456789101112131415161718192021import ( "fmt" "syscall/js")var done = make(chan struct&#123;&#125;)func main() &#123; callback := js.NewCallback(printMessage) defer callback.Close() setPrintMessage := js.Global().Get("setPrintMessage") setPrintMessage.Invoke(callback) &lt;-done&#125;func printMessage(args []js.Value) &#123; message := args[0].String() fmt.Println(message) done &lt;- struct&#123;&#125;&#123;&#125;&#125; 编辑wasm_exec.html，继续重用wasm_exec.js。现在，当点击按钮时，和之前的hello world类似Hello Wasm!消息被输出在console中。 完整代码 持续运行从js调用Go比从Go调用js更麻烦一些，特别是在js部分。这主要是因为需要等待Go回调传递给js，而且执行完就终止了，如何让wasm不会在调用回调之后终止，却继续运行并接收其他调用？ 这一次从Go开始，同样需要创建一个回调并将它发送给js端。并添加一个调用计数器，以便跟踪回调被调用的次数。新的printMessage()函数将打印接收到的消息和调用计数器的值： 1234567var no intfunc printMessage(args []js.Value) &#123; message := args[0].String() no++ fmt.Printf("Message no %d: %s\n", no, message)&#125; 创建回调并将其发送给js端与我们前面的示例中完全相同，但是这一次没有完成的channel来通知什么时候终止主goroutine。一种方法是使用空select无限制地阻塞主goroutine。这不是很优雅，wasm二进制文件永远不会完全关闭，并且可能会在浏览器关闭wasm_exec.html时被kill。另一种方法就是监听页面事件来终止主goroutine。 创建回调来接收页面的beforeunload事件并通过一个channel通知主goroutine。这次新的beforeUnload()函数将只接受一个js.Value参数用来接受事件： 12345var beforeUnloadCh = make(chan struct&#123;&#125;)func beforeUnload(event js.Value) &#123; beforeUnloadCh &lt;- struct&#123;&#125;&#123;&#125;&#125; 然后可以使用js.NewEventCallback()将它包装在一个回调中，并将其注册到js端： 1234beforeUnloadCb := js.NewEventCallback(0, beforeUnload)defer beforeUnloadCb.Close()addEventListener := js.Global.Get("addEventListener")addEventListener.Invoke("beforeunload", beforeUnloadCb) 最后用beforeUnloadCh通道上的接收替换空select： 12&lt;-beforeUnloadChfmt.Println("Bye Wasm !") 最终Go程序如下所示： 123456789101112131415161718192021222324252627282930313233343536package mainimport ( "fmt" "syscall/js")var ( no int beforeUnloadCh = make(chan struct&#123;&#125;))func main() &#123; callback := js.NewCallback(printMessage) defer callback.Close() // This is a good practice setPrintMessage := js.Global.Get("setPrintMessage") setPrintMessage.Invoke(callback) beforeUnloadCb := js.NewEventCallback(0, beforeUnload) defer beforeUnloadCb.Close() addEventListener := js.Global.Get("addEventListener") addEventListener.Invoke("beforeunload", beforeUnloadCb) &lt;-beforeUnloadCh fmt.Println("Bye Wasm !")&#125;func printMessage(args []js.Value) &#123; message := args[0].String() no++ fmt.Printf("Message no %d: %s\n", no, message)&#125;func beforeUnload(event js.Value) &#123; beforeUnloadCh &lt;- struct&#123;&#125;&#123;&#125;&#125; 现在在js部分，这是wasm二进制文件的加载： 1234567const go = new Go();let mod, inst;WebAssembly.instantiateStreaming(fetch("test.wasm"), go.importObject).then((result) =&gt; &#123; mod = result.module; inst = result.instance; document.getElementById("runButton").disabled = false;&#125;); 修改让它在加载后直接启动wasm二进制文件： 123456let run(async function() &#123; const go = new Go() const &#123; instance &#125; = await WebAssembly.instantiateStreaming(fetch("test.wasm"), go.importObject) run = go.run(instance)&#125;)() 通过输入框和按钮来替换我们的Run按钮来触发printMessage()： 12345678&lt;input id="messageInput" type="text" value="Hello Wasm!"&gt;&lt;button onClick="printMessage(document.querySelector('#messageInput').value)" id="printMessageButton" disabled&gt; Print message&lt;/button&gt; 接收和存储回调的setPrintMessage()函数变得简单了： 12345let printMessagefunction setPrintMessage(callback) &#123; printMessage = callback document.querySelector('#printMessageButton').disabled = false&#125; 现在，当点击Print message按钮时，应该看到输入的信息和计数器输出在console中。然后，如果勾选浏览器控制台的Preserve log选项并刷新页面，则应该在console中看到Bye Wasm !。 完整代码 最后上面用简单的例子和较少的代码测试了syscall/jsAPI，Go与js之间更容易的相互调用了。如果感兴趣的可以做一些基准测试比较下Go的wasm与等效的纯js代码的性能。]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>webassembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用direnv来独立项目环境]]></title>
    <url>%2F2018%2F06%2F27%2Fmanaging-project-env-using-direnv%2F</url>
    <content type="text"><![CDATA[概述最近Web Assembly（简称wasm）特性合并到了go主分支上，想尝试一下，但又不想直接把本机的go直接升级成devel版本，于是找到了direnv来独立一个go环境来测试wasm。 direnv是shell的环境切换器。它知道如何挂钩bash，zsh，tcsh，fish和elvish，以根据当前目录加载或卸载环境变量。这允许项目特定的环境变量而不会混淆~/.profile文件。 在每次提示之前，direnv检查当前目录和父目录中是否存在.envrc文件。如果该文件存在（并且已被allow），则将其加载到子shell中，然后所有导出的变量将被direnv捕获，然后提供给当前shell。 安装通过源码安装需要go版本大于1.9123go get github.com/direnv/direnvcd $GOPATH/src/github.com/direnv/direnvmake install 或使用常见的包管理软件安装，如在mac上使用brew：1brew install direnv 使用配置shell如zsh在~/.zshrc文件的末尾添加以下行：1eval "$(direnv hook zsh)" 其他类似，根据文档添加相应的配置。 配置目标目录在目标文件夹中，创建一个.envrc文件并在其中添加一些export指令。请注意，.envrc文件的内容必须是有效的bash语法，无论您使用的是何种shell。这是因为direnv总是用bash执行.envrc，这样direnv可以在shell中工作。如果尝试使用某些在bash中不起作用的语法（如zsh的嵌套扩展），会有问题。 编辑完.envrc会看到direnv警告direnv: error .envrc is blocked.。这是避免自动加载新文件的安全机制，需要手动执行direnv allow批准记载并看到direnv加载新环境。请注意，direnv edit .是一个快捷方式，可以在$EDITOR中打开文件，并在文件被修改自动allow该文件。 进入对应目录，环境自动加载，一旦你从目录中移出，它会自动卸载。如果回到它，它再次被加载。直接进入子目录也会加载。 简单测试下：123cd /path/to/projectecho "echo 'test direnv'" &gt;&gt; .envrcdirenv allow 那么再你再进入这个目录时，就会输出test direnv。 stdlib手动export变量有点麻烦，direnv提供了些实用的函数可以方便的编写.envrc，输入direnv stdlib或在stdlib.sh查看。也可以通过在~/.config/direnv/direnvrc或~/.direnvrc中创建一个bash文件来创建自己的扩展函数。创建一个独立的go环境只要在想要的目录下添加.envrc： 1layout go 加载分层的.envrc假设你有以下结构：12345.└── a ├── .envrc └── b └── .envrc 进入子目录b时只有b下的.envrc会生效，可以在文件里添加source_env ..或source_up来同时加载对应目录或更高级目录的.envrc。 运用使用源码安装特定的go版本，该版本的go就编译好在/your/path/go/bin。123456789cd /your/path/git clone https://go.googlesource.com/gocd go# 添加有需要特性的remote，切换到到对应的版本（分支），非必要# git remote add neelance https://github.com/neelance/go# git fetch --all# git checkout wasm-wip # 该分支当前已经合并到主分支上cd src./all.bash 然后创建新的GOPATH目录 12345.├── .envrc├── bin├── pkg└── src 并编辑.envrc文件 1234PATH_add /your/path/go/binexport GOROOT="/your/path/go"layout go go version查看下版本，可以看到是devel版本 1go version devel +b080abf656 Tue Jun 26 01:57:01 2018 +0000 darwin/amd64 在src创建项目目录并创建main.go 12345package mainfunc main() &#123; println("Hello World, from wasm+Go")&#125; 然后可以拷贝源码里的misc/wasm下文件到同目录，只需要构建一个名为test.wasm的文件，我们就可以重用wasm_exec.html和wasm_exec.js。 1GOARCH=wasm GOOS=js go build -o test.wasm main.go 开启个静态服务。 123456789101112131415package mainimport ( "flag" "log" "net/http")func main() &#123; addr := flag.String("addr", ":8000", "server address:port") flag.Parse() srv := http.FileServer(http.Dir(".")) log.Printf("listening on %q...", *addr) log.Fatal(http.ListenAndServe(*addr, srv))&#125; 并访问wasm_exec.html，点击按钮可以看到console输出了Hello World, from wasm+Go。]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>webassembly</tag>
        <tag>direnv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go中的nil]]></title>
    <url>%2F2018%2F05%2F12%2Fnil-in-go%2F</url>
    <content type="text"><![CDATA[什么是nilnil是Go中熟悉且重要的预先标识的标识符。它是多种类型的零值的字面表示。许多具有某些其他流行语言经验的新Go程序员可能会将null视为其他语言中null（或NULL）的副本。这在一定程度上是正确的，但Go中的nil与其他语言中的null(或None)之间存在许多差异。 nil是预先声明的标识符，你可以使用nil而不用声明它。注意nil不是关键字，可以作为变量名并去改变nil的值。 1234func main() &#123; nil := 1 fmt.Println(nil) // 1&#125; 默认零值与默认类型在Go语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。 123var _ bool // falsevar _ int // 0var _ string // "" nil可以代表许多类型的零值。在Go中，nil可以表示(pointer(including type-unsafe),map,slice,function,channel,interface)类型的零值，*new(T)也等于nil。换句话说，在Go中，nil可能是许多不同类型的值。 12345678910111213var _ *struct&#123;&#125; // nilvar _ []int // nilvar _ map[int]bool // nilvar _ chan string // nilvar _ func() // nilvar _ interface&#123;&#125; // nil_ = *new(*int) // nil_ = *new([]int) // nil_ = *new(map[int]bool) // nil_ = *new(chan string) // nil_ = *new(func()) // nil_ = *new(interface&#123;&#125;) // nil Go中的每个其他预定义标识符都有一个默认类型。但是nil没有默认类型，尽管它有很多可能的类型。编译器必须有足够的信息来从上下文中推导出nil的类型。 123456789_ = 1 // int_ = true // bool_ = (*struct&#123;&#125;)(nil)_ = []int(nil)_ = map[int]bool(nil)_ = chan string(nil)_ = (func())(nil)_ = interface&#123;&#125;(nil) nil的大小一个类型的所有值的内存布局总是相同的。类型的nil值不是例外。nil的大小总是与类型相同的非零值的大小相同。因此，表示不同类型的nil可能具有不同的大小(大小是编译器和架构相关的，以下是64位机器和标准Go编译器的结果)。 1234567891011121314151617var p *struct&#123;&#125; = nilfmt.Println(unsafe.Sizeof(p)) // 8var s []int = nilfmt.Println(unsafe.Sizeof(s)) // 24var m map[int]bool = nilfmt.Println(unsafe.Sizeof(m)) // 8var c chan string = nilfmt.Println(unsafe.Sizeof(c)) // 8var f func() = nilfmt.Println(unsafe.Sizeof(f)) // 8var i interface&#123;&#125; = nilfmt.Println(unsafe.Sizeof(i)) // 16 nil的对比两个不同类型的nil可能不可对比。在Go中，只有两个不同的可比较类型的两个值只能在其中一个可以隐式转换为另一个类型时才能进行比较。具体而言，有三种情况可以比较两种不同可比较的两种值，nil也遵循同样的规则。 两个值中的一个的类型是另一个的基础类型。 两个值之一的类型实现另一个值的类型（必须是interface类型）。 两个值中的一个的类型是定向channel类型，另一个是双向channel类型，且具有相同的元素类型，并且两种类型中的一种不是定义的类型。 注意如果比较的两个nil之一是一个interface，另一个不是，那么比较结果总是false。原因是在进行比较之前，非interface值将被转换为interface值的类型。转换的interface值具有一个具体的动态类型，但另一个interface值没有。这就是为什么比较结果总是false的原因。 1234567891011121314type IntPtr *int// IntPtr的基础类型是* intvar _ = IntPtr(nil) == (*int)(nil)// Go中的每种类型都实现了interface &#123;&#125;类型var _ = (interface&#123;&#125;)(nil) == (*int)(nil) // false// 定向channel类型的值可以转换为具有相同元素类型的双向channel类型var _ = (chan int)(nil) == (chan&lt;- int)(nil)var _ = (chan int)(nil) == (&lt;-chan int)(nil)// 下面这些无法编译通过，无法隐式转换var _ = (*int)(nil) == (*bool)(nil) // error: mismatched types *int and *bool.var _ = (chan int)(nil) == (chan bool)(nil) // error: mismatched types chan int and chan bool. 在Go中，map、slice和function类型不支持比较。因此，比较使用任何类型的不可比类型指定的两个nil是非法的。但是这些类型的任何值都可以与nil标识符进行比较。 123456789// 下面这些无法编译通过var _ = ([]int)(nil) == ([]int)(nil) // error: slice can only be compared to nil.var _ = (map[string]int)(nil) == (map[string]int)(nil) // error: map can only be compared to nil.var _ = (func())(nil) == (func())(nil) // error: func can only be compared to nil.// 以下几行可以编译var _ = ([]int)(nil) == nilvar _ = (map[string]int)(nil) == nilvar _ = (func())(nil) == nil nil的使用在了解了什么是nil之后，再来说说nil的使用场景。 pointers指针表示指向内存的地址，如果对为nil的指针进行解引用的话就会导致panic。 123var p *intp == nil // true*p // panic: invalid memory address or nil pointer dereference 那么为nil的指针有什么用呢？先来看一个计算二叉树和的例子： 1234567891011121314151617type tree struct &#123; v int l *tree r *tree&#125;// first solutionfunc (t *tree) Sum() int &#123; sum := t.v if t.l != nil &#123; sum += t.l.Sum() &#125; if t.r != nil &#123; sum += t.r.Sum() &#125; return sum&#125; 上面的代码有两个问题，一个是代码重复： 123if v != nil &#123; v.m()&#125; 另一个是当t是nil的时候会panic： 12var t *treesum := t.Sum() // panic: invalid memory address or nil pointer dereference 怎么解决上面的问题？我们先来看看一个指针接收器的例子： 12345type person struct &#123;&#125;func sayHi(p *person) &#123; fmt.Println("hi") &#125;func (p *person) sayHi() &#123; fmt.Println("hi") &#125;var p *personp.sayHi() // hi 对于指针对象的方法来说，就算指针的值为nil也是可以调用的，基于此，我们可以对刚刚计算二叉树和的例子进行一下改造： 123456func(t *tree) Sum() int &#123; if t == nil &#123; return 0 &#125; return t.v + t.l.Sum() + t.r.Sum()&#125; 跟刚才的代码一对比是不是简洁了很多？对于nil指针，只需要在方法前面判断一下就ok了，无需重复判断。换成打印二叉树的值或者查找二叉树的某个值都是一样的： 1234567891011121314func(t *tree) String() string &#123; if t == nil &#123; return "" &#125; return fmt.Sprint(t.l, t.v, t.r)&#125;// nil receivers are useful: Findfunc (t *tree) Find(v int) bool &#123; if t == nil &#123; return false &#125; return t.v == v || t.l.Find(v) || t.r.Find(v)&#125; 所以如果不是很需要的话，不要用NewX()去初始化值，而是使用它们的默认值。 slices1234567// nil slicesvar s []Tlen(s) // 0cap(s) // 0for range s &#123;&#125; // iterates zero timess[i] // panic: index out of range 一个为nil的slice，除了不能索引外，其他的操作都是可以的，slice有三个元素，分别是长度、容量、指向数组的指针，当你需要填充值的时候可以使用append函数，slice会自动进行扩充。所以我们并不需要担心slice的大小，使用append的话slice会自动扩容。 map1234567// nil mapsvar m map[T1]T2len(m) // 0for range m &#123;&#125; // 迭代0次v, ok := m[t1] // T2的零值, falsem[t1] = x // panic: assignment to entry in nil map 对于nil的map，我们可以简单把它看成是一个只读的map，不能进行写操作，否则就会panic。 1234567891011func NewGet(url string, headers map[string]string) (*http.Request, error) &#123; req, err := http.NewRequest(http.MethodGet, url, nil) if err != nil &#123; return nil, err &#125; for k, v := range headers &#123; req.Header.Set(k, v) &#125; return req, nil&#125; 对于NewGet来说，我们需要传入一个类型为map的参数，并且这个函数只是对这个参数进行读取，我们可以传入一个非空的值： 123456789NewGet("http://google.com", map[string]string&#123; "USER_AGENT": "golang/gopher",&#125;,)// 为空时NewGet("http://google.com", map[string]string&#123;&#125;)// map的零值是nil，所以当header为空的时候，我们也可以直接传入一个nil：NewGet("http://google.com", nil) channel12345678// nil channelsvar ch chan struct&#123;&#125;// 发送和接受都会永久阻塞&lt;-chch &lt;- struct&#123;&#125;&#123;&#125;close(ch) // panic: runtime error: close of nil channel 这可能起初看起来并不是很有用，如果在使用之前忘记使用make初始化channel。然而，这个属性可以用一些聪明的方式来利用，特别是当你需要在select语句中动态地禁用一个case时。举个例子，假如现在有两个channel负责输入，一个channel负责汇总，简单的实现代码： 12345678910func merge(out chan&lt;- int, a, b &lt;-chan int) &#123; for &#123; select &#123; case v := &lt;-a: out &lt;- v case v := &lt;- b: out &lt;- v &#125; &#125;&#125; 如果在外部调用中关闭了a或者b，那么就会不断地从a或者b中读出0，因为从一个关闭的channel接收会得到channel类型的零值。在我们的例子中, 类型是int, 所以值是 0，这和我们想要的不一样，我们想关闭a和b后就停止汇总了。 首先使用v, ok语法。当使用这个语法时，ok是一个布尔值，channel是开着的，它为true。这样可以避免将多余的零值发送给out。 1v, ok := &lt;- c 然后正如开头提到的那样, 从nil channels接收数据会永远阻塞。所以在知道channel关闭后，为了禁用一个从channel接收数据的case, 我们可以简单将 channel设置为nil 。修改一下代码。 12345678910111213141516171819202122func merge(out chan&lt;- int, a, b &lt;-chan int) &#123; for a != nil || b != nil &#123; select &#123; case v, ok := &lt;-a: if !ok &#123; a = nil fmt.Println("a is nil") continue &#125; out &lt;- v case v, ok := &lt;-b: if !ok &#123; b = nil fmt.Println("b is nil") continue &#125; out &lt;- v &#125; &#125; fmt.Println("close out") close(out)&#125; interfaceinterface并不是一个指针，它的底层实现由两部分组成，一个是类型，一个值，也就是类似于：(Type, Value)。只有当类型和值都是nil的时候，才等于nil。看看下面的代码：123456789func do() error &#123; // error(*doError, nil) var err *doError return err // nil of type *doError&#125;func main() &#123; err := do() fmt.Println(err == nil) // false&#125; 输出结果是false。do函数声明了一个*doErro的变量err，然后返回，返回值是error``interface，但是这个时候的Type已经变成了：(*doError，nil)，所以和nil肯定是不会相等的。所以我们在写函数的时候，不要声明具体的error变量，而是应该直接返回nil： 123func do() error &#123; return nil&#125;]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>nil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go中的monkey patch]]></title>
    <url>%2F2018%2F04%2F22%2Fmonkey-patch-in-go%2F</url>
    <content type="text"><![CDATA[概述monkey patch(猴子补丁)是一种在不改变原始源代码的情况下扩展或修改动态语言的运行时代码的方法。许多人认为猴子修补只限于Python等动态语言。但事实并非如此，我们可以在运行时来修改Go函数。主角就是github.com/bouk/monkey。 猴子补丁主要有以下几个用处： 在运行时替换方法、属性等 在不修改第三方代码的情况下增加原来不支持的功能 在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加 增加钩子，在执行某个方法的同时执行一些其他的处理，如打印日志，实现AOP等。 Examplemonkey库通过修改内存地址的方式，替换目标函数的实际执行地址，实现（几乎）任意函数的mock。你可以指定目标函数，然后定义一个匿名函数替换掉它。替换的记录会存在一个全局表里，不需要的时候可以通过它重新恢复原来的目标函数。 先看一个官方示例： 1234567891011121314151617181920package mainimport ( "fmt" "os" "strings" "github.com/bouk/monkey")func main() &#123; monkey.Patch(fmt.Println, func(a ...interface&#123;&#125;) (n int, err error) &#123; s := make([]interface&#123;&#125;, len(a)) for i, v := range a &#123; s[i] = strings.Replace(fmt.Sprint(v), "hell", "*bleep*", -1) &#125; return fmt.Fprintln(os.Stdout, s...) &#125;) fmt.Println("what the hell?") // what the *bleep*?&#125; 可以看出调用fmt.Println已经替换成我们patch的方法了。 有时候在我们不仅要mock函数，而且在patch方法里还需要调用原来的函数。这时候需要使用monkey库提供的 PatchGuard结构体。关键在于，调用原来的函数之前先调用一次Unpatch，恢复到mock之前的情况；然后在调用了原函数之后，调用一次Restore。 1234567891011121314151617181920212223242526package mainimport ( "fmt" "strings" "github.com/bouk/monkey")func main() &#123; var guard *monkey.PatchGuard guard = monkey.Patch(fmt.Println, func(a ...interface&#123;&#125;) (int, error) &#123; s := make([]interface&#123;&#125;, len(a)) for i, v := range a &#123; s[i] = strings.Replace(fmt.Sprint(v), "hell", "*bleep*", -1) &#125; // 取消patch guard.Unpatch() defer guard.Restore() // 使用默认的fmt.Println return fmt.Println(s...) &#125;) fmt.Println("what the hell?") // what the *bleep*? fmt.Println("what the hell?") // what the *bleep*?&#125; 我们可以用第三方库来替换标准库，且不大范围修改原来代码，比如用json-iterator替换encoding/json来提升json的解析性能。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "encoding/json" "fmt" "github.com/bouk/monkey" jsoniter "github.com/json-iterator/go")type user struct &#123; ID string `json:"id"` Name string `json:"name"`&#125;func main() &#123; monkey.Patch(json.Marshal, func(v interface&#123;&#125;) ([]byte, error) &#123; fmt.Println("use jsoniter marshal") return jsoniter.Marshal(v) &#125;) monkey.Patch(json.Unmarshal, func(data []byte, v interface&#123;&#125;) error &#123; fmt.Println("use jsoniter unmarshal") return jsoniter.Unmarshal(data, v) &#125;) u1 := &amp;user&#123; ID: "1", Name: "0x5010", &#125; u2 := &amp;user&#123;&#125; v, err := json.Marshal(u1) fmt.Println(string(v), err) err = json.Unmarshal(v, u2) fmt.Println(u2, err)&#125; Output:1234use jsoniter marshal&#123;"id":"1","name":"0x5010"&#125; &lt;nil&gt;use jsoniter unmarshal&amp;&#123;1 0x5010&#125; &lt;nil&gt; 注意Go中虽然没有inline关键字，但仍存在inline函数，一个函数是否是inline函数由编译器决定。inline函数的特点是简单短小，在源代码的层次看有函数的结构，而在编译后却不具备函数的性质。inline函数不是在调用时发生控制转移，而是在编译时将函数体嵌入到每一个调用处，所以inline函数在调用时没有地址。通过命令行参数-gcflags=-l禁止inline，避免结果不符合预期。 如果想了解实现原理可以看作者的blog。]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go与堆]]></title>
    <url>%2F2018%2F03%2F30%2Fgo-and-heap%2F</url>
    <content type="text"><![CDATA[概述堆(heap)又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。回忆一下，在队列中，我们可以进行的限定操作是进队列和出队列。出队列是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。 堆的一个经典的实现是完全二叉树(complete binary tree)。这样实现的堆成为二叉堆(binary heap)。完全二叉树是增加了限定条件的二叉树。假设一个二叉树的深度为n。为了满足完全二叉树的要求，该二叉树的前n-1层必须填满，第n层也必须按照从左到右的顺序被填满 container/heap包container/heap为所有实现了heap.Interface的类型提供堆操作。一个堆即是一棵树，这棵树的每个节点的值都比它的子节点的值要小，而整棵树最小的值位于树根root，也即是索引0的位置上。 Fix 函数1func Fix(h Interface, i int) 在索引i上的元素的值发生变化之后，重新修复堆的有序性。先修改索引i上的元素的值然后再执行Fix，跟先调用Remove(h, i)然后再使用 Push 操作将新值重新添加到堆里面的做法具有同等的效果，但前者所需的计算量稍微要少一些。 Fix函数的复杂度为O(log(n))，其中n等于h.Len()。 Init 函数1func Init(h Interface) 在执行任何堆操作之前，必须对堆进行初始化。Init操作对于堆不变性（invariants）具有幂等性，无论堆不变性是否有效，它都可以被调用。 Init函数的复杂度为O(n)，其中 n 等于h.Len()。 Pop 函数1func Pop(h Interface) interface&#123;&#125; Pop函数根据Less的结果，从堆中移除并返回具有最小值的元素，等同于执行Remove(h, 0)。 Pop函数的复杂度为O(log(n))， 其中n等于h.Len()。 Push 函数1func Push(h Interface, x interface&#123;&#125;) Push函数将值为x的元素推入到堆里面，该函数的复杂度为O(log(n))，其中n等于h.Len()。 Remove 函数1func Remove(h Interface, i int) interface&#123;&#125; Remove函数将移除堆中索引为i的元素，该函数的复杂度为O(log(n))，其中 n 等于h.Len()。 Interface 类型任何实现了heap.Interface接口的类型，都可以用作带有以下不变性的最小堆，（换句话说，这个堆在为空、已排序或者调用Init 之后，应该具有以下性质）：1!h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len() 注意， 这个接口中的Push和Pop都是由heap包的实现负责调用的。因此用户在向堆添加元素又或者从堆中移除元素时，需要使用heap.Push以及heap.Pop： 12345type Interface interface &#123; sort.Interface Push(x interface&#123;&#125;) // 将 x 添加为元素 Len() Pop() interface&#123;&#125; // 移除并返回元素 Len() - 1&#125; Example可以先看一下container/heap官方文档的两个范例，整数堆和优先队列。整数堆是最基本的运用，优先队列在业务中是一个常用的场景。 数组中的第K个最大元素这个是leetcode中的一道题，就可以利用整数堆来减少排序元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import "container/heap"// intHeap 是一个由整数组成的最小堆。type intHeap []intfunc (h intHeap) Len() int &#123; return len(h) &#125;func (h intHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125;func (h intHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i] &#125;func (h *intHeap) Push(x interface&#123;&#125;) &#123; // Push 和 Pop 使用 pointer receiver 作为参数， // 因为它们不仅会对切片的内容进行调整，还会修改切片的长度。 *h = append(*h, x.(int))&#125;func (h *intHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125;// min 堆最小元素的值func (h *intHeap) min() int &#123; if len(*h) &gt; 0 &#123; return (*h)[0] &#125; return -1&#125;// 题解func findKthLargest(nums []int, k int) int &#123; // 把前k个元素初始化到堆，此时索引0是当前第k个最大元素，也就是h.min() h := intHeap(nums[:k]) heap.Init(&amp;h) for i := k; i &lt; len(nums); i++ &#123; // 当之后的元素比h.min()小，忽略，否则pop出最小元素，push进新元素 if nums[i] &gt; h.min() &#123; heap.Pop(&amp;h) heap.Push(&amp;h, nums[i]) &#125; &#125; return h.min()&#125; 可以看下提交后的排名。]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>head</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go GraphQL实践（一）]]></title>
    <url>%2F2018%2F03%2F21%2Fgo-graphql-i%2F</url>
    <content type="text"><![CDATA[graphql相信大家对GraphQL早已不陌生，这一Facebook推出的接口查询语言，立志在简洁性和扩展性方面超越REST，并且已经被应用在很多复杂的业务场景中。GraphQL查询时结构化的，信息是类树结构展示的。值类型可以理解为叶子，对象类型可以理解为树干GraphQL是一种描述如何请求数据的语法，通常用于客户端向服务器请求数据。GraphQL层位于客户端和一个或多个数据源之间，按照你的指示接收客户端请求，然后获取必要的数据。 特点无冗余发出一个GraphQL请求就能准确获得你想要的数据，不多不少。GraphQL查询总是返回可预测的结果。使用GraphQL的应用可以工作得又快又稳，因为控制数据的是应用，而不是服务器。 减少请求GraphQL查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询。典型的REST API请求多个资源时得载入多个url，而GraphQL可以通过一次请求就获取你应用所需的所有数据。这样一来，即使是比较慢的移动网络连接下，使用GraphQL的应用也能表现得足够迅速。 强类型GraphQL API是基于类型和字段的方式进行组织的。GraphQL使用强类型来保证请求数据的正确性，提前声明好类型可以避免编写代码手动进行解析。它还提供了清晰的辅助性错误信息。 向下兼容给你的GraphQL API添加字段和类型而无需影响现有查询。老旧的字段可以废弃，从工具中隐藏。通过使用单一演进版本，GraphQL API使得应用始终能够使用新的特性，并鼓励使用更加简洁、更好维护的服务端代码。 只是一个规范GraphQL让你的整个应用共享一套API，而不用被限制于特定存储引擎。GraphQL引擎已经有多种语言实现，通过GraphQL API能够更好利用你的现有数据和代码。你只需要为类型系统的字段编写函数，GraphQL就能通过优化并发的方式来调用它们。 go的实现基础的实现和查询graphql-go/graphql支持查询解析器，不支持GraphQL SDL解析，需要自己编写完整的Field和Schema等。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package mainimport ( "fmt" "github.com/gin-gonic/gin" "github.com/graphql-go/graphql" "github.com/graphql-go/handler")type user struct &#123; ID string `json:"id"` Name string `json:"name"`&#125;var data map[string]user = map[string]user&#123; "1": user&#123; ID: "1", Name: "Dan", &#125;, "2": user&#123; ID: "2", Name: "Lee", &#125;, "3": user&#123; ID: "3", Name: "Nick", &#125;,&#125;var userType = graphql.NewObject( graphql.ObjectConfig&#123; Name: "User", Fields: graphql.Fields&#123; "id": &amp;graphql.Field&#123; Type: graphql.String, &#125;, "name": &amp;graphql.Field&#123; Type: graphql.String, &#125;, &#125;, &#125;,)var queryType = graphql.NewObject( graphql.ObjectConfig&#123; Name: "Query", Fields: graphql.Fields&#123; "user": &amp;graphql.Field&#123; Type: userType, Args: graphql.FieldConfigArgument&#123; "id": &amp;graphql.ArgumentConfig&#123; Type: graphql.String, &#125;, &#125;, Resolve: func(p graphql.ResolveParams) (interface&#123;&#125;, error) &#123; idQuery, isOK := p.Args["id"].(string) if isOK &#123; if v, ok := data[idQuery]; ok &#123; return v, nil &#125; &#125; return nil, nil &#125;, &#125;, &#125;, &#125;,)var schema, _ = graphql.NewSchema( graphql.SchemaConfig&#123; Query: queryType, &#125;,)func executeQuery(query string, schema graphql.Schema, vars map[string]interface&#123;&#125;) *graphql.Result &#123; res := graphql.Do(graphql.Params&#123; Schema: schema, RequestString: query, VariableValues: vars, &#125;) if len(res.Errors) &gt; 0 &#123; fmt.Printf("error: %v", res.Errors) &#125; return res&#125;func main() &#123; query := `query userinfo($uid: String = "1") &#123; user(id: $uid)&#123; id name &#125; &#125; ` vars := map[string]interface&#123;&#125;&#123;"uid": "3"&#125; r := executeQuery(query, schema, vars) rJSON, _ := json.Marshal(r) fmt.Printf("%s \n", rJSON)&#125; 完整代码 http标准库构建http服务只需添加简单几行代码。1234567func main() &#123; http.HandleFunc("/graphql", func(w http.ResponseWriter, r *http.Request) &#123; res := executeQuery(r.URL.Query().Get("query"), schema, nil) json.NewEncoder(w).Encode(res) &#125;) http.ListenAndServe(":8080", nil)&#125; 完整代码我们可以运行代码，并请求一下接口curl -g &#39;http://localhost:8080/graphql?query={user(id:&quot;3&quot;){name}}&#39;，查看结果。 使用graphql-go/handler使用graphql-go/handler简化构建接口代码。使用graphql-go/handler包后不需要自定义graphql.Do去实现查询函数，内部已经帮你做了这些事情。之间在浏览器访问接口可以看到调试页面，可以直接在上面测试请求。1go get github.com/graphql-go/handler 123456789func main() &#123; h := handler.New(&amp;handler.Config&#123; Schema: &amp;schema, Pretty: true, GraphiQL: true, &#125;) http.Handle("/graphql", h) http.ListenAndServe(":8080", nil)&#125; 完整代码 运用于gin使用第三方web库时，只要实现一个handler的转换。1234567891011121314151617func ginHandler() gin.HandlerFunc &#123; h := handler.New(&amp;handler.Config&#123; Schema: &amp;schema, Pretty: true, GraphiQL: true, &#125;) return func(c *gin.Context) &#123; h.ServeHTTP(c.Writer, c.Request) &#125;&#125;func main() &#123; router := gin.Default() router.Any("/graphql", ginHandler()) router.Run(":8080")&#125; 完整代码 graph-gophers/graphql-gograph-gophers/graphql-go是一个用于快速创建严格类型的GraphQL服务器库，支持查询解析器和GraphQL SDL解析。 我们基于它来写一个demo。 首先编写GraphQL SDL(Schema Definition Language) 源码 编写schema.graphql也就是SDL文件 运行go-bindata -ignore=\.go -pkg=schema -o=schema/bindata.go schema/...生成go静态代码 编写schema.go从静态代码中生成schema的string，用于graph-gophers/graphql-go解析 编写GraphQL SDL实现 源码 编写Resolver需要的query方法 根据query需要的返回type实现相应的type resolver 编写Resolver需要的mutation方法 根据mutation需要的input和返回，实现相应的数据结构和处理逻辑 对接数据的存储和修改，代码里用map代替 编写GraphQL Server实现 源码 完整代码]]></content>
      <categories>
        <category>graphql实践</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>graphql</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go与ratelimit]]></title>
    <url>%2F2018%2F03%2F14%2Fgo-and-ratelimit%2F</url>
    <content type="text"><![CDATA[背景限流是对资源访问进行控制，当访问超过承受范围的时候，我们就必须考虑限流来保证接口的可用性或者降级可用性。 限流算法计数器法计数器法是限流算法里最简单也是最容易实现的一种算法。维护一个单位时间内的Counter，当单位时间已经过去则将Counter重置零。这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题。在临界时间的前一毫秒和后一毫秒都触发了最大的请求数，就会在两毫秒内发生了两倍单位时间的最大请求数量。 滑动窗口如果接触过TCP协议的话，那么一定对滑动窗口这个名词不会陌生。在时间窗划分多个格子，每个格子都单独维护一个Counter，窗口每次滑动一个格子。指定时间窗最大请求数，也就是限制的时间范围内允许的最大请求数。计数器算法其实就是滑动窗口算法，只是它没有对时间窗口做进一步地划分，所以只有1格。当维护当滑动窗口的格子划分的越多，限流就会越精确。可是这种方式没有完全解决临界问题，时间窗内一小段流量可能占比特别大。 漏桶算法首先，我们有一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率。而且，当桶满了之后，多余的水将会溢出。该算法保证以一个常速速率来处理请求，所以不会出现临界问题。 令牌桶算法和漏桶算法效果类似但方向相反的算法。桶一开始是空的，token（令牌）以一个固定的速率r往桶里填充，直到达到桶的容量，多余的token将会被丢弃。每当一个请求过来时，就会尝试从桶里移除一个token，如果没有token的话，请求无法通过。令牌桶还可以方便的改变速度。 一旦需要提高速率,只要按需提高放入桶中的token的速率就行了。令牌桶算法允许流量一定程度的突发，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。 算法总结令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要根据具体场景选择合适的算法。 在go中的使用Go提供了一个package(golang.org/x/time/rate)，采用令牌桶的算法实现，用来方便的对速度进行限制。 1234567891011type Limiter struct &#123; limit Limit burst int mu sync.Mutex tokens float64 last time.Time lastEvent time.Time&#125;func NewLimiter(r Limit, b int) *Limiter 首先创建一个rate.Limiter，其有两个参数，第一个参数为允许每秒发生多少次事件，第二个参数是其缓存最大可存多少个事件。这个桶一开始容量为b，装满b个token，然后每秒往里面填充r个token。由于令牌桶中最多有b个token，所以一次最多只能允许b个事件发生，一个事件花费掉一个token。 rate.Limiter提供三种主要的函数。 Wait/WaitN12func (lim *Limiter) Wait(ctx context.Context) (err error)func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) Wait是WaitN(ctx, 1)的简化形式。WaitN阻塞当前直到lim允许n个事件的发生。当没有可用或足够的事件时，将阻塞等待，推荐实际程序中使用这个方法。 Allow/AllowN12func (lim *Limiter) Allow() boolfunc (lim *Limiter) AllowN(now time.Time, n int) bool Allow是函数AllowN(time.Now(), 1)的简化函数。AllowN标识在时间now的时候，n个事件是否可以同时发生(也意思就是now的时候是否可以从令牌桶中取n个token)。适合在超出频率的时候丢弃或跳过事件的场景。 Reserve/ReserveN12func (lim *Limiter) Reserve() *Reservationfunc (lim *Limiter) ReserveN(now time.Time, n int) *Reservation Reserve是ReserveN(time.Now(), 1)的简化形式。ReserveN返回对象Reservation，用于标识调用者需要等多久才能等到n个事件发生(意思就是等多久令牌桶中至少含有n个token)。Wait/WaitN和Allow/AllowN其实就是基于其之上实现的，通过sleep等待时间和直接返回状态。如果想对事件发生的频率和等待处理逻辑更加精细的话就可以使用它。 example123456789101112131415161718192021package mainimport ( "context" "fmt" "time" "golang.org/x/time/rate")func main() &#123; l := rate.NewLimiter(2, 5) ctx := context.Background() start := time.Now() // 要处理二十个事件 for i := 0; i &lt; 20; i++ &#123; l.Wait(ctx) // dosomething &#125; fmt.Println(time.Since(start)) // output: 7.501262697s （初始桶内5个和每秒2个token）&#125;]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝鲜vgo]]></title>
    <url>%2F2018%2F02%2F23%2Fearly-adopters-versioned-go%2F</url>
    <content type="text"><![CDATA[一直以来，对go来说依赖包的版本控制上没有一个好的方案，当前主要有两种方式Import Versioning和Semantic Versioning。 Import Versioning：gopkg.in网站，其实是GitHub版本变化的重定向器，你可以通过gopkg.in/yaml.v1和gopkg.in/yaml.v2 的这样的导入方式来指向Git库的不同提交版本 Semantic Versioning：制定了一个文件格式规范来描述管理vendor目录下代码的准确源和版本信息（dep、glide） 前几天(2018-02-20)Russ Cox博客上介绍了他为go设计的新工具vgo，这是为处理软件包版本而设计的go工具的替代品，vgo即versioned go的缩写，意即带版本的go。vgo目前只能运行在go1.10之上，否则会得到vgo objabi: cannot find GOMIPS这样的错误。 首先安装vgo。 1go get -u golang.org/x/vgo 我们先尝试下，跟着官方示例。 123mkdir $GOPATH/src/hellocd $GOPATH/src/hellocurl -sS https://swtch.com/hello.go &gt; hello.go 我们看一下hello.go的内容。 12345678910package main // import "github.com/you/hello"import ( "fmt" "rsc.io/quote")func main() &#123; fmt.Println(quote.Hello())&#125; 其中// import &quot;github.com/you/hello&quot;注释用来告诉vgo模块的“导入路径名称”应该是什么，并且使用此模块的其他软件包将用作导入标识符。创建一个空的go.mod文件来标记此项目的根目录，然后编译一下。 12echo &gt;go.modvgo build 可以看到生成可执行文件，并修改了go.mod的内容，自动生成了依赖关系。 123module "github.com/you/hello"require "rsc.io/quote" v1.5.2 go.mod文件包含了模块所依赖包的最小版本。如果模块没有提供一个tag版本。对于未命名的提交，v0.0.0-yyyymmddhhmmss-commit表示一个指定日期的提交。go.mod文件还可以实现排除和替换的版本，需手动修改go.mod文件。 123exclude "rsc.io/sampler" v1.99.99replace "rsc.io/quote" v1.5.2 =&gt; "../quote" 但是，最重要的变化还是终结了GOPATH作为Go代码工作空间的设置，由于go.mod文件包含了完整的模块路径并且还定义了每个使用的依赖的版本，因此包含go.mod文件的目录就可以被认为是一个目录树的根目录了，该目录树作用于自身的工作空间，并且和其他类似的目录彼此隔离。 vgo其他功能 123456789vgo list -m # 查看所有依赖vgo list -m -u # 查看所有依赖同时检查更新，会打印出最新版本和当前版本vgo test all # 执行所有测试，包括依赖包的测试vgo test http://rsc.io/sampler # 执行指定包测试vgo get -u # 更新所有依赖vgo list -t http://rsc.io/sampler # 检查指定包所有可用的版本 即tagvgo get http://rsc.io/sampler@v1.3.1 # 获取指定版本，并修改go.modvgo vendor # 退到vendor 兼容不使用vgo的用户... vgo在下载github仓库时，如果当前环境是未认证的账号会受到限流影响，得到如下警告。 123456GitHub applies fairly small rate limits to unauthenticated users, andyou appear to be hitting them. To authenticate, please visithttps://github.com/settings/tokens and click "Generate New Token" tocreate a Personal Access Token. The token only needs "public_repo"scope, but you can add "repo" if you want to access privaterepositories too. 这时候需要获取github token，在github网站依次点击Settings-Developer settings-Personal access tokens-Generate new token，填写名字和勾选权限后生成token。创建或修改$HOME/.netrc文件，添加下行，把生成的token填写进去，就能解决了。 1machine api.github.com login YOU password TOKEN 目前vgo的文档不够完善，代码也不够健壮，在生产环境可能还不适合去使用。我在测试时就遇到了些问题，比如有的gopkg.in仓库使用标签而不是分支来标记主要版本。当前vgo处理这些仓库会出错。 123import ( _ "gopkg.in/natefinch/lumberjack.v2") 将得到如下错误。 1234import "gopkg.in/natefinch/lumberjack.v2": unexpected status (https://api.github.com/repos/natefinch/lumberjack/commits?sha=v2&amp;until=2018-02-23T03%3A49%3A22Z&amp;per_page=2): 404 Not Found# 或vgo: import "gopkg.in/natefinch/lumberjack.v2": unexpected status (https://api.github.com/repos/natefinch/lumberjack): 403 Forbidden 不过vgo应该很快就会修复这些问题。]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>vgo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在linux像脚本语言一样使用go]]></title>
    <url>%2F2018%2F02%2F22%2Fusing-go-as-a-scripting-language-in-linux%2F</url>
    <content type="text"><![CDATA[有时我们想使用go像脚本一样。 12chmod u+x script.go./script.go 乍一看好像很容易实现，在.go文件开头添加shebang（#!）行就可以了。 1#!/usr/bin/env go run 但是这样运行时不能正确地将脚本错误码返回给操作系统。错误码这对于脚本来说很重要，因为错误代码是多个脚本之间相互交互和操作系统环境最常见的方式之一。 而gorun解决了这个问题，安装。 123go get github.com/erning/goruncp $GOPATH/bin/gorun /usr/local/bin # 非必要的，在注册binfmt_misc时使用gorun的绝对路径就行 开头改成： 1#!/usr/bin/env gorun 可是还有个问题，因为Go不知道如何处理#开头的行。其他脚本语言没有这个问题，因为其中大多数#是一种指定注释的方式，但是Go注释以//开头，并且在调用go run或go build会产生错误。 我们中的大多数人都知道Linux（包括一些类Unix操作系统）的可执行文件是ELF二进制格式。其实Linux内核还支持更多二进制格式（用于各种二进制格式的树内模块通常在其名称中具有binfmt_前缀）。值得注意的是binfmt_script模块，它负责解析上面提到的seebang行并在目标系统上执行脚本。但shebang不是Go脚本的最佳选择，而Linux内核有一个合适的模块binfmt_misc。该模块可以通过定义良好的procfs接口直接从用户空间动态添加对各种可执行格式的支持。 根据内核文档，首先安装binfmt_misc 1mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc 现在我们需要告诉binfmt_misc模块如何使用gorun来执行我们的.go文件。 1echo ':golang:E::go::/usr/local/bin/gorun:OC' | sudo tee /proc/sys/fs/binfmt_misc/register 配置字符串:golang:E::go::/usr/local/bin/gorun:OC，它告诉系统：“如果遇到一个带.go扩展名的可执行文件，请使用/usr/local/bin/gorun解释器执行它“。字符串末尾的OC标志确保脚本将根据脚本本身设置的所有者信息和权限位执行，而不是在解释器二进制文件上设置的那些位。这使Go脚本的执行行为与Linux中其他可执行文件和脚本的行为相同。这并没有改变.go文件的内容，自然可以像之前一样的go run和go build。]]></content>
      <categories>
        <category>go技巧</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc-go 连接语义和API]]></title>
    <url>%2F2018%2F02%2F08%2Fgrpc-doc-with-grpc-connectivity-semantics-and-api%2F</url>
    <content type="text"><![CDATA[原文：gRPC Connectivity Semantics and API译文：gitbook译者：0x5010 doc本文档描述了gRPC通道的连接语义以及对RPC的相应影响。然后我们浅谈下API。 连接状态gRPC抽象了客户端与服务器进行通信的方式。客户端通道对象可以使用多于一个DNS名称来创建。通道封装了一系列功能，包括名称解析，建立TCP连接(带有retry和backoff)以及TLS握手。通道还可以处理已建立的连接上的错误并重新连接，或者在HTTP/2 GO_AWAY的情况下，重新解析并重新连接。 为了对使用者隐藏gRPC API(即程序代码)的这些活动的细节，同时暴露有关信道状态的有意义的信息，用具有五种状态的状态机表示，定义如下： CONNECTING: 该通道正在尝试建立连接，正在等待名称解析，TCP连接建立或TLS握手所涉及的其中一个步骤。这可以被用作创建时的通道的初始状态。 READY: 通道已经通过TLS握手(或相当的操作)后一直成功地建立连接，并且所有后续的通信尝试都成功(或者正在等待而没有任何已知的故障)。 TRANSIENT_FAILURE: 出现了一些暂时的故障(如TCP三次握手超时或socket错误)。此状态下的通道最终将切换到CONNECTING状态，并尝试再次建立连接。由于重试是以指数backoff的方式完成的，所以不能连接的信道将在这个状态下花费很少的时间，但是由于尝试重复失败，信道将花费越来越多的时间在这个状态。对于许多非致命故障(例如，由于服务器尚不可用而导致TCP连接尝试超时)，信道可能在此状态下花费越来越多的时间。 IDLE: 这是由于缺乏新的或待处理的RPC，通道甚至不尝试创建连接的状态。新的RPC可以在这个状态下创建。任何尝试在通道上启动RPC都会将通道的状态变更为CONNECTING。当一个指定IDLE_TIMEOUT的通道上没有RPC活动时，即在此期间没有新的或挂起的（活动）RPC时，READY或CONNECTING通道状态变更为IDLE。另外，当没有活动或待处理的RPC时，接收GOAWAY的通道也应变更到IDLE状态，以避免试图断开连接的服务器的连接超载。我们将使用300秒(5分钟)的默认IDLE_TIMEOUT。 SHUTDOWN: 这个通道已经开始关闭了。任何新的RPC应该立即失败。待处理的RPC可能会继续运行，直到程序取消它们。通道可能会进入此状态，因为程序明确要求关闭或在尝试连接通信期间发生了不可恢复的错误(截至2015年12月6日，没有已知的错误(连接或通信中)被归类为不可恢复)。 进入此状态的通道永远不会改变这个状态。 下表列出了从一个状态到另一个状态的转换规则以及相应的原因。-单元格表示不允许的转换。 From/To CONNECTING READY TRANSIENT_FAILURE IDLE SHUTDOWN CONNECTING 在连接建立期间增量 建立连接所需的所有步骤都成功了 在建立连接所需的任何步骤中出现任何故障 通道上没有RPC活动直到IDLE_TIMEOUT 程序触发shutdown READY - 在已建立的通道上增加成功的通话 预期在已建立的通道上成功通信时遇到任何故障 没有活动或待处理的RPC时接收GOAWAY或没有待处理的RPC直到IDLE_TIMEOUT 程序触发shutdown TRANSIENT_FAILURE 指数backoff重试等待时间结束 - - - 程序触发shutdown IDLE 频道上的任何新的RPC活动 - - - 程序触发shutdown SHUTDOWN - - - - - 通道状态API所有的gRPC库都会公开一个通道级别的API方法来轮询当前的通道状态。在C++中，这种方法称为GetState，并返回五个合法状态之一的枚举。如果通道当前是IDLE的，它也接受布尔try_to_connect转换到CONNECTING，他的行为像一个RPC发生，所以它也应该重置IDLE_TIMEOUT。1grpc_connectivity_state GetState(bool try_to_connect); 所有的库都应该公开一个API，使得程序(gRPC API的使用者)在通道状态改变时得到通知。由于状态变化可以很快并且与任何这样的通知竞争，所以通知应该只是通知使用者已经发生了一些状态改变，留给使用者轮询当前状态。 这个API的同步版本是:1bool WaitForStateChange(grpc_connectivity_state source_state, gpr_timespec deadline); 当状态是source_state以外的状态时返回true，如果截止时间到期则返回false。基于异步和期货的API应该有一个相应的方法，允许在通道状态改变时通知程序。 请注意，每次从任何状态转换到其他任何状态时都会发送通知。另一方面，合法状态转换的规则，即使相应的指数回退在重试之前不需要等待，也需要从连接转换到TRANSIENT_FAILURE，并返回连接到每个可恢复故障。综合的影响是应用程序可能会收到虚假的状态更改通知。例如，在CONNECTING状态的通道上等待状态改变的应用程序可以接收状态改变通知，但是在轮询当前状态时找到处于还是CONNECTING状态的通道，因为该通道可能在TRANSIENT_FAILURE状态中花费了无限小的时间量。 grpc-gogo的实现基本同上，除了去掉了try_to_connect的功能。12345678910111213141516func (cc *ClientConn) GetState() connectivity.State &#123; return cc.csMgr.getState()&#125;func (cc *ClientConn) WaitForStateChange(ctx context.Context, sourceState connectivity.State) bool &#123; ch := cc.csMgr.getNotifyChan() if cc.csMgr.getState() != sourceState &#123; return true &#125; select &#123; case &lt;-ctx.Done(): return false case &lt;-ch: return true &#125;&#125; 真正的功能实现在connectivityStateManager中。可以看到ClientConn.WaitForStateChange是通过新建或监听已有notifyChan来感知状态变化。而修改状态的函数updateState在修改状态后，关闭notifyChan来通知所有监听goroutine状态变更。123456789101112131415161718192021222324252627282930313233343536type connectivityStateManager struct &#123; mu sync.Mutex state connectivity.State notifyChan chan struct&#123;&#125;&#125;func (csm *connectivityStateManager) updateState(state connectivity.State) &#123; csm.mu.Lock() defer csm.mu.Unlock() if csm.state == connectivity.Shutdown &#123; return &#125; if csm.state == state &#123; return &#125; csm.state = state if csm.notifyChan != nil &#123; close(csm.notifyChan) csm.notifyChan = nil &#125;&#125;func (csm *connectivityStateManager) getState() connectivity.State &#123; csm.mu.Lock() defer csm.mu.Unlock() return csm.state&#125;func (csm *connectivityStateManager) getNotifyChan() &lt;-chan struct&#123;&#125; &#123; csm.mu.Lock() defer csm.mu.Unlock() if csm.notifyChan == nil &#123; csm.notifyChan = make(chan struct&#123;&#125;) &#125; return csm.notifyChan&#125; 在连接connect时会创建一个goroutine去监控状态变化，通过handleSubConnStateChange(最终调用到connectivityStateManager.updateState)去修改状态。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960func (ac *addrConn) transportMonitor() &#123; for &#123; var timer *time.Timer var cdeadline &lt;-chan time.Time ac.mu.Lock() t := ac.transport // 如果有设置截止时间则生成个定时器 if !ac.connectDeadline.IsZero() &#123; timer = time.NewTimer(ac.connectDeadline.Sub(time.Now())) cdeadline = timer.C &#125; ac.mu.Unlock() // 阻塞，直到我们收到`GoAway`或发生错误 select &#123; case &lt;-t.GoAway(): // GoAway case &lt;-t.Error(): // 错误 case &lt;-cdeadline: // 超时 ac.mu.Lock() if ac.backoffDeadline.IsZero() &#123; ac.mu.Unlock() continue &#125; ac.mu.Unlock() timer = nil grpclog.Warningf("grpc: addrConn.transportMonitor didn't get server preface after waiting. Closing the new transport now.") t.Close() &#125; if timer != nil &#123; timer.Stop() &#125; // 如果GoAway发生了，不管错误如何，适当调整我们的Keepalive参数 select &#123; case &lt;-t.GoAway(): ac.adjustParams(t.GetGoAwayReason()) default: &#125; ac.mu.Lock() if ac.state == connectivity.Shutdown &#123; ac.mu.Unlock() return &#125; // 在调用resetTransport之前，将连接状态设置为TransientFailure。因为无法从READY变成CONNECTING。 ac.state = connectivity.TransientFailure ac.cc.handleSubConnStateChange(ac.acbw, ac.state) ac.cc.resolveNow(resolver.ResolveNowOption&#123;&#125;) ac.curAddr = resolver.Address&#123;&#125; ac.mu.Unlock() // resetTransport将重新创建连接，把状态设置为Connecting if err := ac.resetTransport(); err != nil &#123; ac.mu.Lock() ac.printf("transport exiting: %v", err) ac.mu.Unlock() grpclog.Warningf("grpc: addrConn.transportMonitor exits due to: %v", err) if err != errConnClosing &#123; ac.tearDown(err) &#125; return &#125; &#125;&#125; 遇到错误或手动调用Close时，将状态设置为Shutdown，相关goroutine感知到状态为Shutdown或得到errConnClosing错误时自己退出。1func (cc *ClientConn) Close() error 虽然有Idle状态，但是却没有和docIDLE_TIMEOUT和相关的实现。目前只作为负载均衡中一些连接状态的标记。 当我们想要判断一个连接是不是可用(Ready)状态时，可以：12345678910for &#123; s := cc.GetState() if s == connectivity.Ready &#123; break &#125; if !cc.WaitForStateChange(ctx, s) &#123; // ctx got timeout or canceled. // handle timeout &#125;&#125;]]></content>
      <categories>
        <category>grpc doc与grpc-go的实现</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc-go 连接backoff协议]]></title>
    <url>%2F2018%2F02%2F06%2Fgrpc-doc-with-grpc-connection-backoff%2F</url>
    <content type="text"><![CDATA[原文：gRPC Connection Backoff Protocol译文：gitbook译者：0x5010 doc当我们连接到一个失败的后端时，通常希望不要立即重试(以避免泛滥的网络或服务器的请求)，而是做某种形式的指数backoff。 我们有几个参数： INITIAL_BACKOFF (第一次失败重试前后需等待多久) MULTIPLIER (在失败的重试后乘以的倍数) JITTER (随机抖动因子). MAX_BACKOFF (backoff上限) MIN_CONNECT_TIMEOUT (最短重试间隔) 建议backoff算法以指数形式返回连接尝试的起始时间，达到MAX_BACKOFF的极限，并带有抖动。1234567ConnectWithBackoff() current_backoff = INITIAL_BACKOFF current_deadline = now() + INITIAL_BACKOFF while (TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT))!= SUCCESS) SleepUntil(current_deadline) current_backoff = Min(current_backoff * MULTIPLIER, MAX_BACKOFF) current_deadline = now() + current_backoff + UniformRandom(-JITTER * current_backoff, JITTER * current_backoff) 参数默认值MIN_CONNECT_TIMEOUT=20sec INITIAL_BACKOFF=1sec MULTIPLIER=1.6 MAX_BACKOFF=120sec JITTER=0.2 根据的确切的关注点实现(例如最小化手机的唤醒次数)可能希望使用不同的算法，特别是不同的抖动逻辑。 备用的实现必须确保连接退避在同一时间开始分散，并且不得比上述算法更频繁地尝试连接。 重置backoffbackoff应在某个时间点重置为INITIAL_BACKOFF，以便重新连接行为是一致的，不管连接的是新开始的还是先前断开的连接。 当接收到SETTINGS帧时重置backoff，在那个时候，我们确定这个连接被服务器已经接受了。 grpc-go源码位于google.golang.org/grpc/backoff，代码不多，直接在代码上分析。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import ( "math/rand" "time")// 对应上面的默认值但是没有实现MIN_CONNECT_TIMEOUT参数var DefaultBackoffConfig = BackoffConfig&#123; MaxDelay: 120 * time.Second, baseDelay: 1.0 * time.Second, factor: 1.6, jitter: 0.2,&#125;// backoffStrategy是backoff算法的接口type backoffStrategy interface &#123; // 通过重试次数返回在下一次重试之前等待的时间量 backoff(retries int) time.Duration&#125;type BackoffConfig struct &#123; MaxDelay time.Duration baseDelay time.Duration factor float64 jitter float64&#125;func setDefaults(bc *BackoffConfig) &#123; md := bc.MaxDelay *bc = DefaultBackoffConfig if md &gt; 0 &#123; bc.MaxDelay = md &#125;&#125;// backoff算法的基础实现func (bc BackoffConfig) backoff(retries int) time.Duration &#123; if retries == 0 &#123; return bc.baseDelay &#125; backoff, max := float64(bc.baseDelay), float64(bc.MaxDelay) for backoff &lt; max &amp;&amp; retries &gt; 0 &#123; backoff *= bc.factor retries-- &#125; if backoff &gt; max &#123; backoff = max &#125; // Randomize backoff delays so that if a cluster of requests start at // the same time, they won't operate in lockstep. backoff *= 1 + bc.jitter*(rand.Float64()*2-1) if backoff &lt; 0 &#123; return 0 &#125; return time.Duration(backoff)&#125; 如果默认的backoff算法不满足需求的时候，还可以自定义backoff算法，通过实现backoffStrategy接口。1234567func withBackoff(bs backoffStrategy) DialOption &#123; return func(o *dialOptions) &#123; o.bs = bs &#125;&#125;grpc.Dial(addr, grpc.withBackoff(mybackoff))]]></content>
      <categories>
        <category>grpc doc与grpc-go的实现</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc-go 健康检查]]></title>
    <url>%2F2018%2F02%2F05%2Fgrpc-doc-with-grpc-go-health-checking%2F</url>
    <content type="text"><![CDATA[原文：gRPC Health Checking Protocol译文：gitbook译者：0x5010 doc健康检查用于探测服务器是否能够处理rpc。client到server的健康状况检查可能会发生在点对点或通过某个控制系统。server可能会选择回复“不健康”，因为它没有准备好接受请求，正在关闭或其他原因。如果在一段时间内没有收到回复，或者回复内容不健康，client可以采取相应措施。 使用gRPC service作为对client到server简单场景和其他控制系统(负载均衡)的健康检查机制。作为一个高层次的service带来一些好处。首先，由于它本身是一个gRPC service，所以进行健康检查的形式与正常的rpc相同。其次，它具有丰富的语义，如每个service的健康状况。第三，作为gRPC服务，它可以重用所有现有的如计费和限制基础设施等，因此server可以完全控制健康检查service的访问。 Service定义server由下面的proto中service定义导出：1234567891011121314151617181920syntax = &quot;proto3&quot;;package grpc.health.v1;message HealthCheckRequest &#123; string service = 1;&#125;message HealthCheckResponse &#123; enum ServingStatus &#123; UNKNOWN = 0; SERVING = 1; NOT_SERVING = 2; &#125; ServingStatus status = 1;&#125;service Health &#123; rpc Check(HealthCheckRequest) returns (HealthCheckResponse);&#125; client可以通过调用Check方法来查询service的健康状态，并且应该在rpc上设置超时。client可以选择设置要查询健康状态的服务名称。建议的服务名称格式是package_names.ServiceName，比如grpc.health.v1.Health。 这个server应手动注册所有的service并设置各自的状态，包括空服务名称及其状态。对于收到的每个请求，如果可以在注册表中找到服务名称，则必须以OK状态发回响应，并且相应地将状态字段设置为SERVING或NOT_SERVING。如果服务名称未注册，则服务器返回NOT_FOUND GRPC状态。 server应该使用一个空字符串作为server的整体运行状况的关键字，以便对特定service不感兴趣的client可以用空请求查询服务器的状态。server可以在不支持任何通配符匹配的情况下完成对service名称的精确匹配。但是，service所有者可以自由地实现对client和server一致更复杂的匹配语义。 client如果rpc一段时间后没有完成可以宣布server不健康。client应该能够处理server没有Health service的情况。 grpc-gogrpc-go本身就有实现这个server，我们可以很方便的嵌入到我们的grpc服务中。123456789101112import ( "google.golang.org/grpc" healthpb "google.golang.org/grpc/health/grpc_health_v1")s := grpc.NewServer()pb.RegisterMyServer(s, &amp;myServer&#123;&#125;)// add hsrv := health.NewServer()hsrv.SetServingStatus("", healthpb.HealthCheckResponse_SERVING)healthpb.RegisterHealthServer(s, hsrv)... client部分跟所有正常grpc请求一样，编写下测试代码。12345678cli := healthpb.NewHealthClient(grpcConn)resp, err := cli.Check(context.TODO(), &amp;healthpb.HealthCheckRequest&#123;&#125;)if err != nil &#123; return error&#125;if resp.Status != healthpb.HealthCheckResponse_SERVING &#123; // do something&#125; 很简单就嵌入了健康检查的功能，当然client对状态的判断处理要根据实际场景情况进行相应的处理。]]></content>
      <categories>
        <category>grpc doc与grpc-go的实现</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Functional Options Patter]]></title>
    <url>%2F2018%2F01%2F03%2Fgrpc-functional-options-patter%2F</url>
    <content type="text"><![CDATA[在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方式都用不了。 像构造方法这是一个非常常见的用例，拿它来做例子。比方说,我们有一些名为Client的结构,它有一个连接和附属参数(timeout和retries)，然后我们提供一个构造方法。12345678910111213141516type Client interface &#123; Do() error&#125;type client struct &#123; conn Connection timeout int retries int&#125;func NewClient(conn Connection, timeout, retries int) Client &#123; return &amp;client&#123; conn: conn, timeout: timeout, retries: retries, &#125;&#125; 但是每次调用NewClient时都要提供timeout和retries。而大多数时候只想使用默认值。一个方法是创建另一个不同名称的构造方法。12func NewClient(conn Connection) Clientfunc NewClientWithOptions(conn Connection, timeout, retries int) Client 另一种是传入了一个配置对象。12345type Options struct &#123; Retries int Timeout int&#125;func NewClient(conn Connection, options Options) Client 不够优雅，要么要写非常多的构造方法，要么需要在代码中进行额外的检查和验证或通过传递不关心的参数来为做额外判断的工作。而grpc使用的是一种干净的解决方案: Functional Options Patter。123456789101112131415161718type dialOptions struct &#123; ... insecure bool timeout time.Duration ...&#125;type DialOption func(*dialOptions)type ClientConn struct &#123; ... dopts dialOptions ...&#125;func Dial(target string, opts ...DialOption) (*ClientConn, error) &#123; return DialContext(context.Background(), target, opts...)&#125; ClientConn主要附属参数在dopts中，构造方法Dial参数是可选个数的DialOption。是不是觉得和上面第二种没什么区别，注意传进去的DialOption是方法，先看看库里几个常见的方法的实现。1234567891011func WithInsecure() DialOption &#123; return func(o *dialOptions) &#123; o.insecure = true &#125;&#125;func WithTimeout(d time.Duration) DialOption &#123; return func(o *dialOptions) &#123; o.timeout = d &#125;&#125; dialOptions是可用选项，定义了一些方法WithInsecure和WithTimeout, 它们返回一个闭包函数，用来修改dialOptions的选项。 另外又定义了DialOption, 它是一个接受这些方法。接着我们来看构造方法的关键部分。12345678910111213141516func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) &#123; cc := &amp;ClientConn&#123; target: target, csMgr: &amp;connectivityStateManager&#123;&#125;, conns: make(map[*addrConn]struct&#123;&#125;), blockingpicker: newPickerWrapper(), &#125; ... // 如果想设置默认值可以 cc.dopts = DefaultDopts for _, opt := range opts &#123; opt(&amp;cc.dopts) &#125; ...&#125; 构造函数遍历了DialOption列表, 并对每一项应用返回的闭包运用到的选项dopts。使用起来也很方便。12grpc.Dial(addr, grpc.WithInsecure())grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(time.Duration(10*time.Second))) 而且我们可以随时添加新的选项, 只需要对代码进行非常少量的更改。]]></content>
      <categories>
        <category>grpc-go源码分析</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
</search>
