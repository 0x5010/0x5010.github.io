<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[grpc-go-连接语义和API]]></title>
    <url>%2F2018%2F02%2F08%2Fgrpc-doc-with-grpc-connectivity-semantics-and-api%2F</url>
    <content type="text"><![CDATA[原文：gRPC Connectivity Semantics and API译文：gitbook译者：0x5010 doc本文档描述了gRPC通道的连接语义以及对RPC的相应影响。然后我们浅谈下API。 连接状态gRPC抽象了客户端与服务器进行通信的方式。客户端通道对象可以使用多于一个DNS名称来创建。通道封装了一系列功能，包括名称解析，建立TCP连接(带有retry和backoff)以及TLS握手。通道还可以处理已建立的连接上的错误并重新连接，或者在HTTP/2 GO_AWAY的情况下，重新解析并重新连接。 为了对使用者隐藏gRPC API(即程序代码)的这些活动的细节，同时暴露有关信道状态的有意义的信息，用具有五种状态的状态机表示，定义如下： CONNECTING: 该通道正在尝试建立连接，正在等待名称解析，TCP连接建立或TLS握手所涉及的其中一个步骤。这可以被用作创建时的通道的初始状态。 READY: 通道已经通过TLS握手(或相当的操作)后一直成功地建立连接，并且所有后续的通信尝试都成功(或者正在等待而没有任何已知的故障)。 TRANSIENT_FAILURE: 出现了一些暂时的故障(如TCP三次握手超时或socket错误)。此状态下的通道最终将切换到CONNECTING状态，并尝试再次建立连接。由于重试是以指数backoff的方式完成的，所以不能连接的信道将在这个状态下花费很少的时间，但是由于尝试重复失败，信道将花费越来越多的时间在这个状态。对于许多非致命故障(例如，由于服务器尚不可用而导致TCP连接尝试超时)，信道可能在此状态下花费越来越多的时间。 IDLE: 这是由于缺乏新的或待处理的RPC，通道甚至不尝试创建连接的状态。新的RPC可以在这个状态下创建。任何尝试在通道上启动RPC都会将通道的状态变更为CONNECTING。当一个指定IDLE_TIMEOUT的通道上没有RPC活动时，即在此期间没有新的或挂起的（活动）RPC时，READY或CONNECTING通道状态变更为IDLE。另外，当没有活动或待处理的RPC时，接收GOAWAY的通道也应变更到IDLE状态，以避免试图断开连接的服务器的连接超载。我们将使用300秒(5分钟)的默认IDLE_TIMEOUT。 SHUTDOWN: 这个通道已经开始关闭了。任何新的RPC应该立即失败。待处理的RPC可能会继续运行，直到程序取消它们。通道可能会进入此状态，因为程序明确要求关闭或在尝试连接通信期间发生了不可恢复的错误(截至2015年12月6日，没有已知的错误(连接或通信中)被归类为不可恢复)。 进入此状态的通道永远不会改变这个状态。 下表列出了从一个状态到另一个状态的转换规则以及相应的原因。-单元格表示不允许的转换。 From/To CONNECTING READY TRANSIENT_FAILURE IDLE SHUTDOWN CONNECTING 在连接建立期间增量 建立连接所需的所有步骤都成功了 在建立连接所需的任何步骤中出现任何故障 通道上没有RPC活动直到IDLE_TIMEOUT 程序触发shutdown READY - 在已建立的通道上增加成功的通话 预期在已建立的通道上成功通信时遇到任何故障 没有活动或待处理的RPC时接收GOAWAY或没有待处理的RPC直到IDLE_TIMEOUT 程序触发shutdown TRANSIENT_FAILURE 指数backoff重试等待时间结束 - - - 程序触发shutdown IDLE 频道上的任何新的RPC活动 - - - 程序触发shutdown SHUTDOWN - - - - - 通道状态API所有的gRPC库都会公开一个通道级别的API方法来轮询当前的通道状态。在C++中，这种方法称为GetState，并返回五个合法状态之一的枚举。如果通道当前是IDLE的，它也接受布尔try_to_connect转换到CONNECTING，他的行为像一个RPC发生，所以它也应该重置IDLE_TIMEOUT。1grpc_connectivity_state GetState(bool try_to_connect); 所有的库都应该公开一个API，使得程序(gRPC API的使用者)在通道状态改变时得到通知。由于状态变化可以很快并且与任何这样的通知竞争，所以通知应该只是通知使用者已经发生了一些状态改变，留给使用者轮询当前状态。 这个API的同步版本是:1bool WaitForStateChange(grpc_connectivity_state source_state, gpr_timespec deadline); 当状态是source_state以外的状态时返回true，如果截止时间到期则返回false。基于异步和期货的API应该有一个相应的方法，允许在通道状态改变时通知程序。 请注意，每次从任何状态转换到其他任何状态时都会发送通知。另一方面，合法状态转换的规则，即使相应的指数回退在重试之前不需要等待，也需要从连接转换到TRANSIENT_FAILURE，并返回连接到每个可恢复故障。综合的影响是应用程序可能会收到虚假的状态更改通知。例如，在CONNECTING状态的通道上等待状态改变的应用程序可以接收状态改变通知，但是在轮询当前状态时找到处于还是CONNECTING状态的通道，因为该通道可能在TRANSIENT_FAILURE状态中花费了无限小的时间量。 grpc-gogo的实现基本同上，除了去掉了try_to_connect的功能。12345678910111213141516func (cc *ClientConn) GetState() connectivity.State &#123; return cc.csMgr.getState()&#125;func (cc *ClientConn) WaitForStateChange(ctx context.Context, sourceState connectivity.State) bool &#123; ch := cc.csMgr.getNotifyChan() if cc.csMgr.getState() != sourceState &#123; return true &#125; select &#123; case &lt;-ctx.Done(): return false case &lt;-ch: return true &#125;&#125; 真正的功能实现在connectivityStateManager中。可以看到ClientConn.WaitForStateChange是通过新建或监听已有notifyChan来感知状态变化。而修改状态的函数updateState在修改状态后，关闭notifyChan来通知所有监听goroutine状态变更。123456789101112131415161718192021222324252627282930313233343536type connectivityStateManager struct &#123; mu sync.Mutex state connectivity.State notifyChan chan struct&#123;&#125;&#125;func (csm *connectivityStateManager) updateState(state connectivity.State) &#123; csm.mu.Lock() defer csm.mu.Unlock() if csm.state == connectivity.Shutdown &#123; return &#125; if csm.state == state &#123; return &#125; csm.state = state if csm.notifyChan != nil &#123; close(csm.notifyChan) csm.notifyChan = nil &#125;&#125;func (csm *connectivityStateManager) getState() connectivity.State &#123; csm.mu.Lock() defer csm.mu.Unlock() return csm.state&#125;func (csm *connectivityStateManager) getNotifyChan() &lt;-chan struct&#123;&#125; &#123; csm.mu.Lock() defer csm.mu.Unlock() if csm.notifyChan == nil &#123; csm.notifyChan = make(chan struct&#123;&#125;) &#125; return csm.notifyChan&#125; 在连接connect时会创建一个goroutine去监控状态变化，通过handleSubConnStateChange(最终调用到connectivityStateManager.updateState)去修改状态。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960func (ac *addrConn) transportMonitor() &#123; for &#123; var timer *time.Timer var cdeadline &lt;-chan time.Time ac.mu.Lock() t := ac.transport // 如果有设置截止时间则生成个定时器 if !ac.connectDeadline.IsZero() &#123; timer = time.NewTimer(ac.connectDeadline.Sub(time.Now())) cdeadline = timer.C &#125; ac.mu.Unlock() // 阻塞，直到我们收到`GoAway`或发生错误 select &#123; case &lt;-t.GoAway(): // GoAway case &lt;-t.Error(): // 错误 case &lt;-cdeadline: // 超时 ac.mu.Lock() if ac.backoffDeadline.IsZero() &#123; ac.mu.Unlock() continue &#125; ac.mu.Unlock() timer = nil grpclog.Warningf("grpc: addrConn.transportMonitor didn't get server preface after waiting. Closing the new transport now.") t.Close() &#125; if timer != nil &#123; timer.Stop() &#125; // 如果GoAway发生了，不管错误如何，适当调整我们的Keepalive参数 select &#123; case &lt;-t.GoAway(): ac.adjustParams(t.GetGoAwayReason()) default: &#125; ac.mu.Lock() if ac.state == connectivity.Shutdown &#123; ac.mu.Unlock() return &#125; // 在调用resetTransport之前，将连接状态设置为TransientFailure。因为无法从READY变成CONNECTING。 ac.state = connectivity.TransientFailure ac.cc.handleSubConnStateChange(ac.acbw, ac.state) ac.cc.resolveNow(resolver.ResolveNowOption&#123;&#125;) ac.curAddr = resolver.Address&#123;&#125; ac.mu.Unlock() // resetTransport将重新创建连接，把状态设置为Connecting if err := ac.resetTransport(); err != nil &#123; ac.mu.Lock() ac.printf("transport exiting: %v", err) ac.mu.Unlock() grpclog.Warningf("grpc: addrConn.transportMonitor exits due to: %v", err) if err != errConnClosing &#123; ac.tearDown(err) &#125; return &#125; &#125;&#125; 遇到错误或手动调用Close时，将状态设置为Shutdown，相关goroutine感知到状态为Shutdown或得到errConnClosing错误时自己退出。1func (cc *ClientConn) Close() error 虽然有Idle状态，但是却没有和docIDLE_TIMEOUT和相关的实现。目前只作为负载均衡中一些连接状态的标记。 当我们想要判断一个连接是不是可用(Ready)状态时，可以：12345678910for &#123; s := cc.GetState() if s == connectivity.Ready &#123; break &#125; if !cc.WaitForStateChange(ctx, s) &#123; // ctx got timeout or canceled. // handle timeout &#125;&#125;]]></content>
      <categories>
        <category>grpc doc与grpc-go的实现</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc-go-连接backoff协议]]></title>
    <url>%2F2018%2F02%2F06%2Fgrpc-doc-with-grpc-connection-backoff%2F</url>
    <content type="text"><![CDATA[原文：gRPC Connection Backoff Protocol译文：gitbook译者：0x5010 doc当我们连接到一个失败的后端时，通常希望不要立即重试(以避免泛滥的网络或服务器的请求)，而是做某种形式的指数backoff。 我们有几个参数： INITIAL_BACKOFF (第一次失败重试前后需等待多久) MULTIPLIER (在失败的重试后乘以的倍数) JITTER (随机抖动因子). MAX_BACKOFF (backoff上限) MIN_CONNECT_TIMEOUT (最短重试间隔) 建议backoff算法以指数形式返回连接尝试的起始时间，达到MAX_BACKOFF的极限，并带有抖动。1234567ConnectWithBackoff() current_backoff = INITIAL_BACKOFF current_deadline = now() + INITIAL_BACKOFF while (TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT))!= SUCCESS) SleepUntil(current_deadline) current_backoff = Min(current_backoff * MULTIPLIER, MAX_BACKOFF) current_deadline = now() + current_backoff + UniformRandom(-JITTER * current_backoff, JITTER * current_backoff) 参数默认值MIN_CONNECT_TIMEOUT=20sec INITIAL_BACKOFF=1sec MULTIPLIER=1.6 MAX_BACKOFF=120sec JITTER=0.2 根据的确切的关注点实现(例如最小化手机的唤醒次数)可能希望使用不同的算法，特别是不同的抖动逻辑。 备用的实现必须确保连接退避在同一时间开始分散，并且不得比上述算法更频繁地尝试连接。 重置backoffbackoff应在某个时间点重置为INITIAL_BACKOFF，以便重新连接行为是一致的，不管连接的是新开始的还是先前断开的连接。 当接收到SETTINGS帧时重置backoff，在那个时候，我们确定这个连接被服务器已经接受了。 grpc-go源码位于google.golang.org/grpc/backoff，代码不多，直接在代码上分析。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import ( "math/rand" "time")// 对应上面的默认值但是没有实现MIN_CONNECT_TIMEOUT参数var DefaultBackoffConfig = BackoffConfig&#123; MaxDelay: 120 * time.Second, baseDelay: 1.0 * time.Second, factor: 1.6, jitter: 0.2,&#125;// backoffStrategy是backoff算法的接口type backoffStrategy interface &#123; // 通过重试次数返回在下一次重试之前等待的时间量 backoff(retries int) time.Duration&#125;type BackoffConfig struct &#123; MaxDelay time.Duration baseDelay time.Duration factor float64 jitter float64&#125;func setDefaults(bc *BackoffConfig) &#123; md := bc.MaxDelay *bc = DefaultBackoffConfig if md &gt; 0 &#123; bc.MaxDelay = md &#125;&#125;// backoff算法的基础实现func (bc BackoffConfig) backoff(retries int) time.Duration &#123; if retries == 0 &#123; return bc.baseDelay &#125; backoff, max := float64(bc.baseDelay), float64(bc.MaxDelay) for backoff &lt; max &amp;&amp; retries &gt; 0 &#123; backoff *= bc.factor retries-- &#125; if backoff &gt; max &#123; backoff = max &#125; // Randomize backoff delays so that if a cluster of requests start at // the same time, they won't operate in lockstep. backoff *= 1 + bc.jitter*(rand.Float64()*2-1) if backoff &lt; 0 &#123; return 0 &#125; return time.Duration(backoff)&#125; 如果默认的backoff算法不满足需求的时候，还可以自定义backoff算法，通过实现backoffStrategy接口。1234567func withBackoff(bs backoffStrategy) DialOption &#123; return func(o *dialOptions) &#123; o.bs = bs &#125;&#125;grpc.Dial(addr, grpc.withBackoff(mybackoff))]]></content>
      <categories>
        <category>grpc doc与grpc-go的实现</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc-go-健康检查]]></title>
    <url>%2F2018%2F02%2F05%2Fgrpc-doc-with-grpc-go-health-checking%2F</url>
    <content type="text"><![CDATA[原文：gRPC Health Checking Protocol译文：gitbook译者：0x5010 doc健康检查用于探测服务器是否能够处理rpc。client到server的健康状况检查可能会发生在点对点或通过某个控制系统。server可能会选择回复“不健康”，因为它没有准备好接受请求，正在关闭或其他原因。如果在一段时间内没有收到回复，或者回复内容不健康，client可以采取相应措施。 使用gRPC service作为对client到server简单场景和其他控制系统(负载均衡)的健康检查机制。作为一个高层次的service带来一些好处。首先，由于它本身是一个gRPC service，所以进行健康检查的形式与正常的rpc相同。其次，它具有丰富的语义，如每个service的健康状况。第三，作为gRPC服务，它可以重用所有现有的如计费和限制基础设施等，因此server可以完全控制健康检查service的访问。 Service定义server由下面的proto中service定义导出：1234567891011121314151617181920syntax = &quot;proto3&quot;;package grpc.health.v1;message HealthCheckRequest &#123; string service = 1;&#125;message HealthCheckResponse &#123; enum ServingStatus &#123; UNKNOWN = 0; SERVING = 1; NOT_SERVING = 2; &#125; ServingStatus status = 1;&#125;service Health &#123; rpc Check(HealthCheckRequest) returns (HealthCheckResponse);&#125; client可以通过调用Check方法来查询service的健康状态，并且应该在rpc上设置超时。client可以选择设置要查询健康状态的服务名称。建议的服务名称格式是package_names.ServiceName，比如grpc.health.v1.Health。 这个server应手动注册所有的service并设置各自的状态，包括空服务名称及其状态。对于收到的每个请求，如果可以在注册表中找到服务名称，则必须以OK状态发回响应，并且相应地将状态字段设置为SERVING或NOT_SERVING。如果服务名称未注册，则服务器返回NOT_FOUND GRPC状态。 server应该使用一个空字符串作为server的整体运行状况的关键字，以便对特定service不感兴趣的client可以用空请求查询服务器的状态。server可以在不支持任何通配符匹配的情况下完成对service名称的精确匹配。但是，service所有者可以自由地实现对client和server一致更复杂的匹配语义。 client如果rpc一段时间后没有完成可以宣布server不健康。client应该能够处理server没有Health service的情况。 grpc-gogrpc-go本身就有实现这个server，我们可以很方便的嵌入到我们的grpc服务中。123456789101112import ( "google.golang.org/grpc" healthpb "google.golang.org/grpc/health/grpc_health_v1")s := grpc.NewServer()pb.RegisterMyServer(s, &amp;myServer&#123;&#125;)// add hsrv := health.NewServer()hsrv.SetServingStatus("", healthpb.HealthCheckResponse_SERVING)healthpb.RegisterHealthServer(s, hsrv)... client部分跟所有正常grpc请求一样，编写下测试代码。12345678cli := healthpb.NewHealthClient(grpcConn)resp, err := cli.Check(context.TODO(), &amp;healthpb.HealthCheckRequest&#123;&#125;)if err != nil &#123; return error&#125;if resp.Status != healthpb.HealthCheckResponse_SERVING &#123; // do something&#125; 很简单就嵌入了健康检查的功能，当然client对状态的判断处理要根据实际场景情况进行相应的处理。]]></content>
      <categories>
        <category>grpc doc与grpc-go的实现</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Functional Options Patter]]></title>
    <url>%2F2018%2F01%2F03%2Fgrpc-functional-options-patter%2F</url>
    <content type="text"><![CDATA[在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方式都用不了。 像构造方法这是一个非常常见的用例，拿它来做例子。比方说,我们有一些名为Client的结构,它有一个连接和附属参数(timeout和retries)，然后我们提供一个构造方法。12345678910111213141516type Client interface &#123; Do() error&#125;type client struct &#123; conn Connection timeout int retries int&#125;func NewClient(conn Connection, timeout, retries int) Client &#123; return &amp;client&#123; conn: conn, timeout: timeout, retries: retries, &#125;&#125; 但是每次调用NewClient时都要提供timeout和retries。而大多数时候只想使用默认值。一个方法是创建另一个不同名称的构造方法。12func NewClient(conn Connection) Clientfunc NewClientWithOptions(conn Connection, timeout, retries int) Client 另一种是传入了一个配置对象。12345type Options struct &#123; Retries int Timeout int&#125;func NewClient(conn Connection, options Options) Client 不够优雅，要么要写非常多的构造方法，要么需要在代码中进行额外的检查和验证或通过传递不关心的参数来为做额外判断的工作。而grpc使用的是一种干净的解决方案: Functional Options Patter。123456789101112131415161718type dialOptions struct &#123; ... insecure bool timeout time.Duration ...&#125;type DialOption func(*dialOptions)type ClientConn struct &#123; ... dopts dialOptions ...&#125;func Dial(target string, opts ...DialOption) (*ClientConn, error) &#123; return DialContext(context.Background(), target, opts...)&#125; ClientConn主要附属参数在dopts中，构造方法Dial参数是可选个数的DialOption。是不是觉得和上面第二种没什么区别，注意传进去的DialOption是方法，先看看库里几个常见的方法的实现。1234567891011func WithInsecure() DialOption &#123; return func(o *dialOptions) &#123; o.insecure = true &#125;&#125;func WithTimeout(d time.Duration) DialOption &#123; return func(o *dialOptions) &#123; o.timeout = d &#125;&#125; dialOptions是可用选项，定义了一些方法WithInsecure和WithTimeout, 它们返回一个闭包函数，用来修改dialOptions的选项。 另外又定义了DialOption, 它是一个接受这些方法。接着我们来看构造方法的关键部分。12345678910111213141516func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) &#123; cc := &amp;ClientConn&#123; target: target, csMgr: &amp;connectivityStateManager&#123;&#125;, conns: make(map[*addrConn]struct&#123;&#125;), blockingpicker: newPickerWrapper(), &#125; ... // 如果想设置默认值可以 cc.dopts = DefaultDopts for _, opt := range opts &#123; opt(&amp;cc.dopts) &#125; ...&#125; 构造函数遍历了DialOption列表, 并对每一项应用返回的闭包运用到的选项dopts。使用起来也很方便。12grpc.Dial(addr, grpc.WithInsecure())grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(time.Duration(10*time.Second))) 而且我们可以随时添加新的选项, 只需要对代码进行非常少量的更改。]]></content>
      <categories>
        <category>grpc-go源码分析</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
</search>
