<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[grpc doc与grpc-go的实现-健康检查]]></title>
    <url>%2F2018%2F02%2F05%2Fgrpc-doc-with-grpc-go-health-checking%2F</url>
    <content type="text"><![CDATA[原文：gRPC Health Checking Protocol译文：gitbook译者：0x5010 doc健康检查用于探测服务器是否能够处理rpc。client到server的健康状况检查可能会发生在点对点或通过某个控制系统。server可能会选择回复“不健康”，因为它没有准备好接受请求，正在关闭或其他原因。如果在一段时间内没有收到回复，或者回复内容不健康，client可以采取相应措施。 使用gRPC service作为对client到server简单场景和其他控制系统(负载均衡)的健康检查机制。作为一个高层次的service带来一些好处。首先，由于它本身是一个gRPC service，所以进行健康检查的形式与正常的rpc相同。其次，它具有丰富的语义，如每个service的健康状况。第三，作为gRPC服务，它可以重用所有现有的如计费和限制基础设施等，因此server可以完全控制健康检查service的访问。 Service定义server由下面的proto中service定义导出：1234567891011121314151617181920syntax = "proto3";package grpc.health.v1;message HealthCheckRequest &#123; string service = 1;&#125;message HealthCheckResponse &#123; enum ServingStatus &#123; UNKNOWN = 0; SERVING = 1; NOT_SERVING = 2; &#125; ServingStatus status = 1;&#125;service Health &#123; rpc Check(HealthCheckRequest) returns (HealthCheckResponse);&#125; client可以通过调用Check方法来查询service的健康状态，并且应该在rpc上设置超时。client可以选择设置要查询健康状态的服务名称。建议的服务名称格式是package_names.ServiceName，比如grpc.health.v1.Health。 这个server应手动注册所有的service并设置各自的状态，包括空服务名称及其状态。对于收到的每个请求，如果可以在注册表中找到服务名称，则必须以OK状态发回响应，并且相应地将状态字段设置为SERVING或NOT_SERVING。如果服务名称未注册，则服务器返回NOT_FOUND GRPC状态。 server应该使用一个空字符串作为server的整体运行状况的关键字，以便对特定service不感兴趣的client可以用空请求查询服务器的状态。server可以在不支持任何通配符匹配的情况下完成对service名称的精确匹配。但是，service所有者可以自由地实现对client和server一致更复杂的匹配语义。 client如果rpc一段时间后没有完成可以宣布server不健康。client应该能够处理server没有Health service的情况。 grpc-gogrpc-go本身就有实现这个server，我们可以很方便的嵌入到我们的grpc服务中。123456789101112import ( "google.golang.org/grpc" healthpb "google.golang.org/grpc/health/grpc_health_v1")s := grpc.NewServer()pb.RegisterMyServer(s, &amp;myServer&#123;&#125;)// add hsrv := health.NewServer()hsrv.SetServingStatus("", healthpb.HealthCheckResponse_SERVING)healthpb.RegisterHealthServer(s, hsrv)... client部分跟所有正常grpc请求一样，编写下测试代码。12345678cli := healthpb.NewHealthClient(grpcConn)resp, err := cli.Check(context.TODO(), &amp;healthpb.HealthCheckRequest&#123;&#125;)if err != nil &#123; return error&#125;if resp.Status != healthpb.HealthCheckResponse_SERVING &#123; // do something&#125; 很简单就嵌入了健康检查的功能，当然client对状态的判断处理要根据实际场景情况进行相应的处理。]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grpc源码分析-Functional Options Patter]]></title>
    <url>%2F2018%2F01%2F03%2Fgrpc-functional-options-patter%2F</url>
    <content type="text"><![CDATA[在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方式都用不了。 像构造方法这是一个非常常见的用例，拿它来做例子。比方说,我们有一些名为Client的结构,它有一个连接和附属参数(timeout和retries)，然后我们提供一个构造方法。12345678910111213141516type Client interface &#123; Do() error&#125;type client struct &#123; conn Connection timeout int retries int&#125;func NewClient(conn Connection, timeout, retries int) Client &#123; return &amp;client&#123; conn: conn, timeout: timeout, retries: retries, &#125;&#125; 但是每次调用NewClient时都要提供timeout和retries。而大多数时候只想使用默认值。一个方法是创建另一个不同名称的构造方法。12func NewClient(conn Connection) Clientfunc NewClientWithOptions(conn Connection, timeout, retries int) Client 另一种是传入了一个配置对象。12345type Options struct &#123; Retries int Timeout int&#125;func NewClient(conn Connection, options Options) Client 不够优雅，要么要写非常多的构造方法，要么需要在代码中进行额外的检查和验证或通过传递不关心的参数来为做额外判断的工作。而grpc使用的是一种干净的解决方案: Functional Options Patter。123456789101112131415161718type dialOptions struct &#123; ... insecure bool timeout time.Duration ...&#125;type DialOption func(*dialOptions)type ClientConn struct &#123; ... dopts dialOptions ...&#125;func Dial(target string, opts ...DialOption) (*ClientConn, error) &#123; return DialContext(context.Background(), target, opts...)&#125; ClientConn主要附属参数在dopts中，构造方法Dial参数是可选个数的DialOption。是不是觉得和上面第二种没什么区别，注意传进去的DialOption是方法，先看看库里几个常见的方法的实现。1234567891011func WithInsecure() DialOption &#123; return func(o *dialOptions) &#123; o.insecure = true &#125;&#125;func WithTimeout(d time.Duration) DialOption &#123; return func(o *dialOptions) &#123; o.timeout = d &#125;&#125; dialOptions是可用选项，定义了一些方法WithInsecure和WithTimeout, 它们返回一个闭包函数，用来修改dialOptions的选项。 另外又定义了DialOption, 它是一个接受这些方法。接着我们来看构造方法的关键部分。12345678910111213141516func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) &#123; cc := &amp;ClientConn&#123; target: target, csMgr: &amp;connectivityStateManager&#123;&#125;, conns: make(map[*addrConn]struct&#123;&#125;), blockingpicker: newPickerWrapper(), &#125; ... // 如果想设置默认值可以 cc.dopts = DefaultDopts for _, opt := range opts &#123; opt(&amp;cc.dopts) &#125; ...&#125; 构造函数遍历了DialOption列表, 并对每一项应用返回的闭包运用到的选项dopts。使用起来也很方便。12grpc.Dial(addr, grpc.WithInsecure())grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(time.Duration(10*time.Second))) 而且我们可以随时添加新的选项, 只需要对代码进行非常少量的更改。]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>grpc</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
</search>
