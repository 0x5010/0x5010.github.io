<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>keyboardman</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.keyboardman.me/"/>
  <updated>2018-02-06T02:21:01.000Z</updated>
  <id>http://blog.keyboardman.me/</id>
  
  <author>
    <name>0x5010</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>grpc-go-连接backoff协议</title>
    <link href="http://blog.keyboardman.me/2018/02/06/grpc-doc-with-grpc-connection-backoff/"/>
    <id>http://blog.keyboardman.me/2018/02/06/grpc-doc-with-grpc-connection-backoff/</id>
    <published>2018-02-06T02:21:01.000Z</published>
    <updated>2018-02-06T02:21:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md" target="_blank" rel="noopener">gRPC Connection Backoff Protocol</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/connection-backoff.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h1 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h1><p>当我们连接到一个失败的后端时，通常希望不要立即重试(以避免泛滥的网络或服务器的请求)，而是做某种形式的指数backoff。</p><p>我们有几个参数：</p><ol><li>INITIAL_BACKOFF (第一次失败重试前后需等待多久)</li><li>MULTIPLIER (在失败的重试后乘以的倍数)</li><li>JITTER (随机抖动因子).</li><li>MAX_BACKOFF (backoff上限)</li><li>MIN_CONNECT_TIMEOUT (最短重试间隔)</li></ol><h2 id="建议backoff算法"><a href="#建议backoff算法" class="headerlink" title="建议backoff算法"></a>建议backoff算法</h2><p>以指数形式返回连接尝试的起始时间，达到MAX_BACKOFF的极限，并带有抖动。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectWithBackoff()</span><br><span class="line">  current_backoff = INITIAL_BACKOFF</span><br><span class="line">  current_deadline = now() + INITIAL_BACKOFF</span><br><span class="line">  <span class="keyword">while</span> (TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT))!= SUCCESS)</span><br><span class="line">    SleepUntil(current_deadline)</span><br><span class="line">    current_backoff = Min(current_backoff * MULTIPLIER, MAX_BACKOFF)</span><br><span class="line">    current_deadline = now() + current_backoff + UniformRandom(-JITTER * current_backoff, JITTER * current_backoff)</span><br></pre></td></tr></table></figure></p><p>参数默认值<code>MIN_CONNECT_TIMEOUT</code>=20sec <code>INITIAL_BACKOFF</code>=1sec <code>MULTIPLIER</code>=1.6 <code>MAX_BACKOFF</code>=120sec <code>JITTER</code>=0.2</p><p>根据的确切的关注点实现(例如最小化手机的唤醒次数)可能希望使用不同的算法，特别是不同的抖动逻辑。</p><p>备用的实现必须确保连接退避在同一时间开始分散，并且不得比上述算法更频繁地尝试连接。</p><h2 id="重置backoff"><a href="#重置backoff" class="headerlink" title="重置backoff"></a>重置backoff</h2><p>backoff应在某个时间点重置为<code>INITIAL_BACKOFF</code>，以便重新连接行为是一致的，不管连接的是新开始的还是先前断开的连接。</p><p>当接收到<code>SETTINGS</code>帧时重置backoff，在那个时候，我们确定这个连接被服务器已经接受了。</p><hr><h1 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h1><p>源码位于<code>google.golang.org/grpc/backoff</code>，代码不多，直接在代码上分析。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应上面的默认值但是没有实现MIN_CONNECT_TIMEOUT参数</span></span><br><span class="line"><span class="keyword">var</span> DefaultBackoffConfig = BackoffConfig&#123;</span><br><span class="line">MaxDelay:  <span class="number">120</span> * time.Second,</span><br><span class="line">baseDelay: <span class="number">1.0</span> * time.Second,</span><br><span class="line">factor:    <span class="number">1.6</span>,</span><br><span class="line">jitter:    <span class="number">0.2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backoffStrategy是backoff算法的接口</span></span><br><span class="line"><span class="keyword">type</span> backoffStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过重试次数返回在下一次重试之前等待的时间量</span></span><br><span class="line">backoff(retries <span class="keyword">int</span>) time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BackoffConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">MaxDelay time.Duration</span><br><span class="line">baseDelay time.Duration</span><br><span class="line">factor <span class="keyword">float64</span></span><br><span class="line">jitter <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDefaults</span><span class="params">(bc *BackoffConfig)</span></span> &#123;</span><br><span class="line">md := bc.MaxDelay</span><br><span class="line">*bc = DefaultBackoffConfig</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> md &gt; <span class="number">0</span> &#123;</span><br><span class="line">bc.MaxDelay = md</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backoff算法的基础实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc BackoffConfig)</span> <span class="title">backoff</span><span class="params">(retries <span class="keyword">int</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> retries == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bc.baseDelay</span><br><span class="line">&#125;</span><br><span class="line">backoff, max := <span class="keyword">float64</span>(bc.baseDelay), <span class="keyword">float64</span>(bc.MaxDelay)</span><br><span class="line"><span class="keyword">for</span> backoff &lt; max &amp;&amp; retries &gt; <span class="number">0</span> &#123;</span><br><span class="line">backoff *= bc.factor</span><br><span class="line">retries--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> backoff &gt; max &#123;</span><br><span class="line">backoff = max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Randomize backoff delays so that if a cluster of requests start at</span></span><br><span class="line"><span class="comment">// the same time, they won't operate in lockstep.</span></span><br><span class="line">backoff *= <span class="number">1</span> + bc.jitter*(rand.Float64()*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> backoff &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> time.Duration(backoff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果默认的backoff算法不满足需求的时候，还可以自定义backoff算法，通过实现backoffStrategy接口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withBackoff</span><span class="params">(bs backoffStrategy)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.bs = bs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grpc.Dial(addr, grpc.withBackoff(mybackoff))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC Connecti
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-健康检查</title>
    <link href="http://blog.keyboardman.me/2018/02/05/grpc-doc-with-grpc-go-health-checking/"/>
    <id>http://blog.keyboardman.me/2018/02/05/grpc-doc-with-grpc-go-health-checking/</id>
    <published>2018-02-05T09:24:22.000Z</published>
    <updated>2018-02-05T09:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">gRPC Health Checking Protocol</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/health-checking.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h1 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h1><p>健康检查用于探测服务器是否能够处理rpc。client到server的健康状况检查可能会发生在点对点或通过某个控制系统。server可能会选择回复“不健康”，因为它没有准备好接受请求，正在关闭或其他原因。如果在一段时间内没有收到回复，或者回复内容不健康，client可以采取相应措施。</p><p>使用gRPC service作为对client到server简单场景和其他控制系统(负载均衡)的健康检查机制。作为一个高层次的service带来一些好处。首先，由于它本身是一个gRPC service，所以进行健康检查的形式与正常的rpc相同。其次，它具有丰富的语义，如每个service的健康状况。第三，作为gRPC服务，它可以重用所有现有的如计费和限制基础设施等，因此server可以完全控制健康检查service的访问。</p><h2 id="Service定义"><a href="#Service定义" class="headerlink" title="Service定义"></a>Service定义</h2><p>server由下面的proto中service定义导出：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  string service = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    SERVING = 1;</span><br><span class="line">    NOT_SERVING = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client可以通过调用<code>Check</code>方法来查询service的健康状态，并且应该在rpc上设置超时。client可以选择设置要查询健康状态的服务名称。建议的服务名称格式是<code>package_names.ServiceName</code>，比如<code>grpc.health.v1.Health</code>。</p><p>这个server应手动注册所有的service并设置各自的状态，包括空服务名称及其状态。对于收到的每个请求，如果可以在注册表中找到服务名称，则必须以<code>OK</code>状态发回响应，并且相应地将状态字段设置为<code>SERVING</code>或<code>NOT_SERVING</code>。如果服务名称未注册，则服务器返回<code>NOT_FOUND</code> GRPC状态。</p><p>server应该使用一个空字符串作为server的整体运行状况的关键字，以便对特定service不感兴趣的client可以用空请求查询服务器的状态。server可以在不支持任何通配符匹配的情况下完成对service名称的精确匹配。但是，service所有者可以自由地实现对client和server一致更复杂的匹配语义。</p><p>client如果rpc一段时间后没有完成可以宣布server不健康。client应该能够处理server没有<code>Health</code> service的情况。</p><hr><h1 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h1><p><code>grpc-go</code>本身就有实现这个server，我们可以很方便的嵌入到我们的grpc服务中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line">healthpb <span class="string">"google.golang.org/grpc/health/grpc_health_v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">pb.RegisterMyServer(s, &amp;myServer&#123;&#125;)</span><br><span class="line"><span class="comment">// add </span></span><br><span class="line">hsrv := health.NewServer()</span><br><span class="line">hsrv.SetServingStatus(<span class="string">""</span>, healthpb.HealthCheckResponse_SERVING)</span><br><span class="line">healthpb.RegisterHealthServer(s, hsrv)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>client部分跟所有正常grpc请求一样，编写下测试代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cli := healthpb.NewHealthClient(grpcConn)</span><br><span class="line">resp, err := cli.Check(context.TODO(), &amp;healthpb.HealthCheckRequest&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.Status != healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很简单就嵌入了健康检查的功能，当然client对状态的判断处理要根据实际场景情况进行相应的处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC Health Chec
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>Functional Options Patter</title>
    <link href="http://blog.keyboardman.me/2018/01/03/grpc-functional-options-patter/"/>
    <id>http://blog.keyboardman.me/2018/01/03/grpc-functional-options-patter/</id>
    <published>2018-01-03T07:57:25.000Z</published>
    <updated>2018-02-05T09:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方式都用不了。</p><p>像构造方法这是一个非常常见的用例，拿它来做例子。比方说,我们有一些名为<code>Client</code>的结构,它有一个连接和附属参数(timeout和retries)，然后我们提供一个构造方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">interface</span> &#123;</span><br><span class="line">    Do() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> client <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    Connection</span><br><span class="line">    timeout <span class="keyword">int</span></span><br><span class="line">    retries <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">Client</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;client&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: timeout,</span><br><span class="line">        retries: retries,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是每次调用NewClient时都要提供<code>timeout</code>和<code>retries</code>。而大多数时候只想使用默认值。<br>一个方法是创建另一个不同名称的构造方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection)</span> <span class="title">Client</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewClientWithOptions</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">Client</span></span></span><br></pre></td></tr></table></figure></p><p>另一种是传入了一个配置对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    Retries <span class="keyword">int</span> </span><br><span class="line">    Timeout <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection, options Options)</span> <span class="title">Client</span></span></span><br></pre></td></tr></table></figure></p><p>不够优雅，要么要写非常多的构造方法，要么需要在代码中进行额外的检查和验证或通过传递不关心的参数来为做额外判断的工作。而grpc使用的是一种干净的解决方案: Functional Options Patter。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dialOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">insecure    <span class="keyword">bool</span></span><br><span class="line">timeout     time.Duration</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DialOption <span class="function"><span class="keyword">func</span><span class="params">(*dialOptions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ClientConn</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">dopts        dialOptions</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(*ClientConn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> DialContext(context.Background(), target, opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ClientConn</code>主要附属参数在<code>dopts</code>中，构造方法<code>Dial</code>参数是可选个数的<code>DialOption</code>。是不是觉得和上面第二种没什么区别，注意传进去的<code>DialOption</code>是方法，先看看库里几个常见的方法的实现。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithInsecure</span><span class="params">()</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.insecure = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(d time.Duration)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.timeout = d</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>dialOptions</code>是可用选项，定义了一些方法<code>WithInsecure</code>和<code>WithTimeout</code>, 它们返回一个闭包函数，用来修改<code>dialOptions</code>的选项。 另外又定义了<code>DialOption</code>, 它是一个接受这些方法。接着我们来看构造方法的关键部分。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">cc := &amp;ClientConn&#123;</span><br><span class="line">target: target,</span><br><span class="line">csMgr:  &amp;connectivityStateManager&#123;&#125;,</span><br><span class="line">conns:  <span class="built_in">make</span>(<span class="keyword">map</span>[*addrConn]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line"></span><br><span class="line">blockingpicker: newPickerWrapper(),</span><br><span class="line">&#125;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// 如果想设置默认值可以 cc.dopts = DefaultDopts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(&amp;cc.dopts)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造函数遍历了DialOption列表, 并对每一项应用返回的闭包运用到的选项<code>dopts</code>。使用起来也很方便。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grpc.Dial(addr, grpc.WithInsecure())</span><br><span class="line">grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(time.Duration(<span class="number">10</span>*time.Second)))</span><br></pre></td></tr></table></figure></p><p>而且我们可以随时添加新的选项, 只需要对代码进行非常少量的更改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方
      
    
    </summary>
    
      <category term="grpc-go源码分析" scheme="http://blog.keyboardman.me/categories/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="源码分析" scheme="http://blog.keyboardman.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
