<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>keyboardman</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.keyboardman.me/"/>
  <updated>2018-07-30T12:10:59.570Z</updated>
  <id>http://blog.keyboardman.me/</id>
  
  <author>
    <name>0x5010</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go与json</title>
    <link href="http://blog.keyboardman.me/2018/07/30/go-and-json/"/>
    <id>http://blog.keyboardman.me/2018/07/30/go-and-json/</id>
    <published>2018-07-30T12:05:50.311Z</published>
    <updated>2018-07-30T12:10:59.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>日常开发中经常要在<code>json</code>对象与<code>Go struct</code>之间相互转换。由于<code>Go</code>是一个静态类型的语言，没办法像动态语言那么方便的序列化反序列化<code>json</code>，特别是<code>json</code>的来源不受控的时候。虽然可以使用<code>map[string]interface{}</code>表示动态类型，但是导致非常难看和难以维护的代码。本篇试着使用一些小技巧让序列化<code>json</code>变得更优雅。</p><h2 id="动态的json"><a href="#动态的json" class="headerlink" title="动态的json"></a>动态的json</h2><p>假定一个场景邮件<code>Envelope</code>，不同的邮件类型的<code>msg</code>字段拥有不一样的结构。比如如下两个邮件<code>json</code>对象的<code>msg</code>字段的结构是不一样的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"sound"</span>,</span><br><span class="line"><span class="attr">"msg"</span>: &#123;</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"dynamite"</span>,</span><br><span class="line"><span class="attr">"authority"</span>: <span class="string">"the Bruce Dickinson"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"cowbell"</span>,</span><br><span class="line"><span class="attr">"msg"</span>: &#123;</span><br><span class="line"><span class="attr">"more"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>先定义一些基本类型，使用<code>interface{}</code>来包含不同的数据结构来序列化成不同类型的邮件<code>json</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Envelope <span class="keyword">struct</span> &#123;</span><br><span class="line">Type <span class="keyword">string</span>      <span class="string">`json:"type"`</span></span><br><span class="line">Msg  <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:"msg"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sound <span class="keyword">struct</span> &#123;</span><br><span class="line">Description <span class="keyword">string</span> <span class="string">`json:"description"`</span></span><br><span class="line">Authority   <span class="keyword">string</span> <span class="string">`json:"authority"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cowbell <span class="keyword">struct</span> &#123;</span><br><span class="line">More <span class="keyword">bool</span> <span class="string">`json:"more"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>试着运行一下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s := Envelope&#123;</span><br><span class="line">Type: <span class="string">"sound"</span>,</span><br><span class="line">Msg: &amp;Sound&#123;</span><br><span class="line">Description: <span class="string">"dynamite"</span>,</span><br><span class="line">Authority:   <span class="string">"the Bruce Dickinson"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">buf, err := json.Marshal(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, buf)  </span><br><span class="line"><span class="comment">// &#123;"type":"sound","msg":&#123;"description":"dynamite","authority":"the Bruce Dickinson"&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">c := Envelope&#123;</span><br><span class="line">Type: <span class="string">"cowbell"</span>,</span><br><span class="line">Msg: &amp;Cowbell&#123;</span><br><span class="line">More: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">buf, err = json.Marshal(c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, buf)  </span><br><span class="line"><span class="comment">// &#123;"type":"cowbell","msg":&#123;"more":true&#125;&#125;</span></span><br></pre></td></tr></table></figure></p><p>没有什么特殊的。<br><a href="https://github.com/0x5010/example/blob/master/json/marshal/main.go" target="_blank" rel="noopener">完整代码</a></p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>当我们要反序列化<code>json</code>到<code>Envelope</code>，那么使用<code>map[string]interface{}</code>来解析<code>msg</code>是很多人喜欢的做法，但是这不是很优雅，而且很容易出错。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">input := <span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "type": "sound",</span></span><br><span class="line"><span class="string">    "msg": &#123;</span></span><br><span class="line"><span class="string">        "description": "dynamite",</span></span><br><span class="line"><span class="string">        "authority": "the Bruce Dickinson"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">var</span> env Envelope</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(input), &amp;env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">desc := env.Msg.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">"description"</span>].(<span class="keyword">string</span>)</span><br><span class="line">fmt.Println(desc)</span><br><span class="line"><span class="comment">// dynamite</span></span><br></pre></td></tr></table></figure></p><h3 id="使用RawMessage"><a href="#使用RawMessage" class="headerlink" title="使用RawMessage"></a>使用RawMessage</h3><p><a href="http://golang.org/pkg/encoding/json/#RawMessage" target="_blank" rel="noopener">json.RawMessage</a>是一个有用的类型，可以让你推迟反序列化，其实它只是将原始数据存储为<code>[]byte</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Envelope <span class="keyword">struct</span> &#123;</span><br><span class="line">Type <span class="keyword">string</span>           <span class="string">`json:"type"`</span></span><br><span class="line">Msg  *json.RawMessage <span class="string">`json:"msg"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样可以明确地控制<code>json</code>的反序列话，并且因为延迟，我们要用到有不同类型分支的数据才去处理。但是序列化的时候要先明确数据结构，如果独立<code>EnvelopeIn</code>和<code>EnvelopeOut</code>分别用来序列化和反序列化，也不好，其实我们可以结合<code>json.RawMessage</code>和<code>interface{}</code>来使用，不必修改<code>Envelope</code>的结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg json.RawMessage</span><br><span class="line">env := Envelope&#123;</span><br><span class="line">Msg: &amp;msg,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(input), &amp;env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> env.Type &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sound"</span>:</span><br><span class="line"><span class="keyword">var</span> s Sound</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(msg, &amp;s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">desc := s.Description</span><br><span class="line">fmt.Println(desc)</span><br><span class="line"><span class="comment">// dynamite</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Fatalf(<span class="string">"unknown message type: %q"</span>, env.Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/0x5010/example/blob/master/json/unmarshal/main.go" target="_blank" rel="noopener">完整代码</a></p><h2 id="拆分和组合"><a href="#拆分和组合" class="headerlink" title="拆分和组合"></a>拆分和组合</h2><p>尽管期望<code>json</code>格式比较规范，有分支字段放在一个键下面，但是有时还是会从外部接受到不好的数据格式，比如数据都在顶层。我们可以使用拆分分别使用这些值，也可以如注释组合成一个大的<code>struct</code>来处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">input := <span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "type": "sound",</span></span><br><span class="line"><span class="string">    "description": "dynamite",</span></span><br><span class="line"><span class="string">    "authority": "the Bruce Dickinson"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">var</span> env Envelope</span><br><span class="line">buf := []<span class="keyword">byte</span>(input)</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(buf, &amp;env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> env.Type &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sound"</span>:</span><br><span class="line"><span class="keyword">var</span> env Envelope</span><br><span class="line"><span class="keyword">var</span> s Sound</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(buf, &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">*Envelope</span><br><span class="line">*Sound</span><br><span class="line">&#125;&#123;&amp;env, &amp;s&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s := struct &#123;</span></span><br><span class="line"><span class="comment">// *Envelope</span></span><br><span class="line"><span class="comment">// *Sound</span></span><br><span class="line"><span class="comment">// &#125;&#123;&#125;</span></span><br><span class="line"><span class="comment">// if err := json.Unmarshal(buf, &amp;s); err != nil &#123;</span></span><br><span class="line"><span class="comment">// log.Fatal(err)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">desc := s.Description</span><br><span class="line">fmt.Println(desc)</span><br><span class="line"><span class="comment">// dynamite</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Fatalf(<span class="string">"unknown message type: %q"</span>, env.Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/0x5010/example/blob/master/json/split_compose/main.go" target="_blank" rel="noopener">完整代码</a></p><h2 id="忽略字段"><a href="#忽略字段" class="headerlink" title="忽略字段"></a>忽略字段</h2><p>当要序列化<code>Sound</code>的时候想要忽略<code>Authority</code>字段，可以使用组合的方法覆盖掉原有的参数属性：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> omit *<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OmitSound <span class="keyword">struct</span> &#123;</span><br><span class="line">*Sound</span><br><span class="line">Authority omit <span class="string">`json:"authority,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的技巧是不设置<code>OmitSound</code>的<code>Authority</code>字段，因为它是一个指针类型，默认值为<code>nil</code>，它将被省略（因为<code>omitempty</code>）。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;Sound&#123;</span><br><span class="line">Description: <span class="string">"dynamite"</span>,</span><br><span class="line">Authority:   <span class="string">"the Bruce Dickinson"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf, err := json.Marshal(OmitSound&#123;</span><br><span class="line">Sound: s,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// buf, err := json.Marshal(struct &#123;</span></span><br><span class="line"><span class="comment">// *Sound</span></span><br><span class="line"><span class="comment">// Authority bool `json:"authority,omitempty"`</span></span><br><span class="line"><span class="comment">// &#125;&#123;</span></span><br><span class="line"><span class="comment">// Sound: s,</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, buf)</span><br><span class="line"><span class="comment">// &#123;"description":"dynamite"&#125;</span></span><br></pre></td></tr></table></figure></p><p>也可以像注释中之间使用匿名<code>struct</code>，忽略的字段可以使用<code>*struct{}</code>甚至<code>bool</code>或<code>int</code>，使用哪种内置类型无关紧要，只要它具有<code>omitempty</code>标记识别的<a href="https://blog.keyboardman.me/2018/05/12/nil-in-go/">零值</a>即可。</p><p><a href="https://github.com/0x5010/example/blob/master/json/omit/main.go" target="_blank" rel="noopener">完整代码</a></p><h2 id="添加额外的字段"><a href="#添加额外的字段" class="headerlink" title="添加额外的字段"></a>添加额外的字段</h2><p>添加字段比省略更简单。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;Sound&#123;</span><br><span class="line">Description: <span class="string">"dynamite"</span>,</span><br><span class="line">Authority:   <span class="string">"the Bruce Dickinson"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf, err := json.Marshal(<span class="keyword">struct</span> &#123;</span><br><span class="line">*Sound</span><br><span class="line">Other <span class="keyword">string</span> <span class="string">`json:"other"`</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">Sound: s,</span><br><span class="line">Other: <span class="string">"other"</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, buf)</span><br><span class="line"><span class="comment">// &#123;"description":"dynamite","authority":"the Bruce Dickinson","other":"other"&#125;</span></span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/0x5010/example/blob/master/json/add/main.go" target="_blank" rel="noopener">完整代码</a></p><h2 id="重命名字段"><a href="#重命名字段" class="headerlink" title="重命名字段"></a>重命名字段</h2><p>重命名其实是忽略和添加额外字段的组合。请注意，仅当要重命名大<code>struct</code>中的一个或两个字段时，这才是实用的。当重命名所有（大部分）字段时，通常创建一个新<code>struct</code>会比较合适。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;Sound&#123;</span><br><span class="line">Description: <span class="string">"dynamite"</span>,</span><br><span class="line">Authority:   <span class="string">"the Bruce Dickinson"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf, err := json.Marshal(<span class="keyword">struct</span> &#123;</span><br><span class="line">*Sound</span><br><span class="line"></span><br><span class="line"><span class="comment">// omit keys</span></span><br><span class="line">OmitAuthority <span class="keyword">string</span> <span class="string">`json:"authority,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add keys</span></span><br><span class="line">Authority <span class="keyword">string</span> <span class="string">`json:"author"`</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">Sound:     s,</span><br><span class="line">Authority: s.Authority,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, buf)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/0x5010/example/blob/master/json/rename/main.go" target="_blank" rel="noopener">完整代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;日常开发中经常要在&lt;code&gt;json&lt;/code&gt;对象与&lt;code&gt;Go struct&lt;/code&gt;之间相互转换。由于&lt;code&gt;Go&lt;/
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="json" scheme="http://blog.keyboardman.me/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>你好WebAssembly</title>
    <link href="http://blog.keyboardman.me/2018/06/28/hello-webassembly/"/>
    <id>http://blog.keyboardman.me/2018/06/28/hello-webassembly/</id>
    <published>2018-06-28T07:29:58.657Z</published>
    <updated>2018-06-28T10:57:51.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://blog.keyboardman.me/2018/06/27/managing-project-env-using-direnv/">上篇</a>介绍了如何成功执行了<code>Go</code>编译的第一个<code>WebAssembly</code>(以下简称<code>wasm</code>)二进制文件，接着进一步测试下<code>Go</code>的<code>wasm</code>的能实现的功能。</p><h2 id="从Go调用JS"><a href="#从Go调用JS" class="headerlink" title="从Go调用JS"></a>从Go调用JS</h2><p><code>Go</code>的标准库有一个新的包<code>syscall/js</code>，先看下<code>js.go</code>文件。里面定义了个新的类型<code>js.Value</code>，它表示一个<code>JavaScript</code>值。它提供了一个简单的API来操纵任何类型的<code>JavaScript</code>值并与之交互：</p><ul><li><code>js.Value.Get()</code>和<code>js.Value.Set()</code>检索并设置<code>Object</code>值的属性</li><li><code>js.Value.Index()</code>和<code>js.Value.SetIndex()</code>检索并设置<code>Array</code>值中的值</li><li><code>js.Value.Call()</code>在一个<code>Object</code>值上调用一个方法 </li><li><code>js.Value.Invoke()</code>调用一个函数值 </li><li><code>js.Value.New()</code>在代表<code>JS</code>类型的引用上调用<code>new</code>运算符</li><li>在相应的<code>Go</code>类型中检索<code>JavaScript</code>值的其他方法（如<code>js.Value.Int()</code>或<code>js.Value.Bool()</code>）</li></ul><p>一个<code>js.ValueOf()</code>函数，它接受任何<code>Go</code>基本类型并返回相应的<code>js.Value</code>。 </p><p>最后是一些有趣的变量：</p><ul><li><code>js.Undefined</code>与<code>js</code>的<code>undefined</code>对应的<code>js.Value</code> </li><li><code>js.Null</code>与<code>js</code>的<code>null</code>对应的<code>js.Value</code> </li><li><code>js.Global</code>允许访问<code>js</code>全局范围的<code>js.Value</code></li></ul><p>尝试调用下<code>js</code>的<code>window.alert()</code>将消息其显示在对话框中，而不是发送到<code>console</code>。</p><p>由于在浏览器中，<code>global</code>就是<code>window</code>，从<code>global</code>中检索<code>alert()</code>，于是有了一个<code>alert</code>类型的<code>js.Value</code>变量，它是对<code>js</code>的<code>window.alert</code>的引用，在其上使用<code>js.Value.Invoke()</code>。可以发现在将参数传递给<code>Invoke</code>之前不需要调用<code>js.ValueOf()</code>，它接受<code>interface{}</code>参数，并通过调用<code>ValueOf</code>去运行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"syscall/js"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">alert := js.Global().Get(<span class="string">"alert"</span>)</span><br><span class="line">alert.Invoke(<span class="string">"Hello wasm!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当点击按钮时，会弹出一条包含<code>Hello wasm!</code>消息的对话框。</p><p><a href="https://github.com/0x5010/example/tree/master/wasm/js_call" target="_blank" rel="noopener">完整代码</a></p><h2 id="从JS调用Go"><a href="#从JS调用Go" class="headerlink" title="从JS调用Go"></a>从JS调用Go</h2><p>如上从<code>Go</code>调用<code>js</code>非常简单，接着看<code>callback.go</code>文件。里面定义了一个新的<code>js.Callback</code>类型，它代表一个<code>Go</code>的<code>func</code>包装以便用作<code>js</code>回调。一个<code>js.NewCallback()</code>函数，它接受一个<code>js.Value</code>切片（并且不返回任何内容）并返回一个<code>js.Callback</code>。并提供一些机制来管理活动回调，以及一个<code>js.Callback.Close()</code>函数，当不再使用回调时必须调用它来释放相应资源。另外还有一个<code>js.NewEventCallback()</code>函数来接受js事件。</p><p>先试着做一些简单的事情，从<code>js</code>端触发<code>Go</code>的<code>fmt.Println</code>。</p><p>当前执行<code>wasm</code>二进制文件的<code>run()</code>函数如下所示，需要在<code>wasm_exec.html</code>中进行一些调整，让它能够从<code>Go</code>接收回调并调用它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.clear()</span><br><span class="line">    <span class="keyword">await</span> go.run(ist)</span><br><span class="line">    inst = <span class="keyword">await</span> WebAssembly.instantiate(mod, go.importObject)</span><br></pre></td></tr></table></figure><p>它启动<code>wasm</code>二进制文件并等待它终止，然后重新实例化它以便下次运行。添加一个新的函数，它将接收并存储<code>Go</code>回调，并在完成后立即解析<code>Promise</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printMessage</span><br><span class="line"><span class="keyword">let</span> printMessageReceived</span><br><span class="line"><span class="keyword">let</span> resolvePrintMessageReceived</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPrintMessage</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    printMessage = callback</span><br><span class="line">    resolvePrintMessageReceived()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在调整<code>run()</code>函数以使用回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.clear()</span><br><span class="line">    printMessageReceived = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        resolvePrintMessageReceived = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> run = go.run(inst)</span><br><span class="line">    <span class="keyword">await</span> printMessageReceived</span><br><span class="line">    printMessage(<span class="string">'Hello Wasm!'</span>)</span><br><span class="line">    <span class="keyword">await</span> run</span><br><span class="line">    inst = <span class="keyword">await</span> WebAssembly.instantiate(mod, go.importObject)</span><br></pre></td></tr></table></figure><p>现在<code>Go</code>部分需要创建回调，将其发送给<code>js</code>端并等待它被调用。需要一个<code>channel</code>来通知回调被调用了，然后编写实际的<code>printMessage()``func</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMessage</span><span class="params">(args []js.Value)</span></span> &#123;</span><br><span class="line">    message := args[<span class="number">0</span>].String()</span><br><span class="line">    fmt.Println(message)</span><br><span class="line">    done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如所看到的，参数是在<code>js.Value</code>的切片中接收到的，在第一个元素上调用<code>js.Value.String()</code>转化为<code>Go</code>的<code>string</code>来获取message。现在可以在回调中包装这个<code>func</code>，然后调用<code>js</code>的<code>setPrintMessage()</code>函数，就像调用<code>window.alert()</code>时一样，最后就是等待回调被调用，这个很重要，因为回调是在<code>goroutine</code>中执行的，因此主<code>goroutine</code>必须等待回调被调用，否则<code>wasm</code>二进制会提前终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">callback := js.NewCallback(printMessage)</span><br><span class="line"><span class="keyword">defer</span> callback.Close()</span><br><span class="line"></span><br><span class="line">setPrintMessage := js.Global().Get(<span class="string">"setPrintMessage"</span>)</span><br><span class="line">setPrintMessage.Invoke(callback)</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br></pre></td></tr></table></figure><p>完整的<code>Go</code>程序应如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"syscall/js"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">callback := js.NewCallback(printMessage)</span><br><span class="line"><span class="keyword">defer</span> callback.Close()</span><br><span class="line"></span><br><span class="line">setPrintMessage := js.Global().Get(<span class="string">"setPrintMessage"</span>)</span><br><span class="line">setPrintMessage.Invoke(callback)</span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMessage</span><span class="params">(args []js.Value)</span></span> &#123;</span><br><span class="line">message := args[<span class="number">0</span>].String()</span><br><span class="line">fmt.Println(message)</span><br><span class="line">done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑<code>wasm_exec.html</code>，继续重用<code>wasm_exec.js</code>。现在，当点击按钮时，和之前的<code>hello world</code>类似<code>Hello Wasm!</code>消息被输出在<code>console</code>中。</p><p><a href="https://github.com/0x5010/example/tree/master/wasm/go_call" target="_blank" rel="noopener">完整代码</a></p><h2 id="持续运行"><a href="#持续运行" class="headerlink" title="持续运行"></a>持续运行</h2><p>从<code>js</code>调用<code>Go</code>比从<code>Go</code>调用<code>js</code>更麻烦一些，特别是在<code>js</code>部分。这主要是因为需要等待<code>Go</code>回调传递给<code>js</code>，而且执行完就终止了，如何让<code>wasm</code>不会在调用回调之后终止，却继续运行并接收其他调用？</p><p>这一次从<code>Go</code>开始，同样需要创建一个回调并将它发送给<code>js</code>端。并添加一个调用计数器，以便跟踪回调被调用的次数。新的<code>printMessage()</code>函数将打印接收到的消息和调用计数器的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> no <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMessage</span><span class="params">(args []js.Value)</span></span> &#123;</span><br><span class="line">    message := args[<span class="number">0</span>].String()</span><br><span class="line">    no++</span><br><span class="line">    fmt.Printf(<span class="string">"Message no %d: %s\n"</span>, no, message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建回调并将其发送给<code>js</code>端与我们前面的示例中完全相同，但是这一次没有完成的<code>channel</code>来通知什么时候终止主<code>goroutine</code>。一种方法是使用空<code>select</code>无限制地阻塞主<code>goroutine</code>。这不是很优雅，<code>wasm</code>二进制文件永远不会完全关闭，并且可能会在浏览器关闭<code>wasm_exec.html</code>时被<code>kill</code>。另一种方法就是监听页面事件来终止主<code>goroutine</code>。</p><p>创建回调来接收页面的<code>beforeunload</code>事件并通过一个<code>channel</code>通知主<code>goroutine</code>。这次新的<code>beforeUnload()</code>函数将只接受一个<code>js.Value</code>参数用来接受事件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> beforeUnloadCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beforeUnload</span><span class="params">(event js.Value)</span></span> &#123;</span><br><span class="line">    beforeUnloadCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用<code>js.NewEventCallback()</code>将它包装在一个回调中，并将其注册到<code>js</code>端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeUnloadCb := js.NewEventCallback(<span class="number">0</span>, beforeUnload)</span><br><span class="line"><span class="keyword">defer</span> beforeUnloadCb.Close()</span><br><span class="line">addEventListener := js.Global.Get(<span class="string">"addEventListener"</span>)</span><br><span class="line">addEventListener.Invoke(<span class="string">"beforeunload"</span>, beforeUnloadCb)</span><br></pre></td></tr></table></figure><p>最后用<code>beforeUnloadCh</code>通道上的接收替换空<code>select</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;-beforeUnloadCh</span><br><span class="line">fmt.Println(<span class="string">"Bye Wasm !"</span>)</span><br></pre></td></tr></table></figure><p>最终<code>Go</code>程序如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"syscall/js"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">no             <span class="keyword">int</span></span><br><span class="line">beforeUnloadCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">callback := js.NewCallback(printMessage)</span><br><span class="line"><span class="keyword">defer</span> callback.Close() <span class="comment">// This is a good practice</span></span><br><span class="line">setPrintMessage := js.Global.Get(<span class="string">"setPrintMessage"</span>)</span><br><span class="line">setPrintMessage.Invoke(callback)</span><br><span class="line"></span><br><span class="line">beforeUnloadCb := js.NewEventCallback(<span class="number">0</span>, beforeUnload)</span><br><span class="line"><span class="keyword">defer</span> beforeUnloadCb.Close()</span><br><span class="line">addEventListener := js.Global.Get(<span class="string">"addEventListener"</span>)</span><br><span class="line">addEventListener.Invoke(<span class="string">"beforeunload"</span>, beforeUnloadCb)</span><br><span class="line"></span><br><span class="line">&lt;-beforeUnloadCh</span><br><span class="line">fmt.Println(<span class="string">"Bye Wasm !"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMessage</span><span class="params">(args []js.Value)</span></span> &#123;</span><br><span class="line">message := args[<span class="number">0</span>].String()</span><br><span class="line">no++</span><br><span class="line">fmt.Printf(<span class="string">"Message no %d: %s\n"</span>, no, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beforeUnload</span><span class="params">(event js.Value)</span></span> &#123;</span><br><span class="line">beforeUnloadCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在<code>js</code>部分，这是<code>wasm</code>二进制文件的加载：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="keyword">new</span> Go();</span><br><span class="line"><span class="keyword">let</span> mod, inst;</span><br><span class="line">WebAssembly.instantiateStreaming(fetch(<span class="string">"test.wasm"</span>), go.importObject).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">mod = result.module;</span><br><span class="line">inst = result.instance;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"runButton"</span>).disabled = <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修改让它在加载后直接启动<code>wasm</code>二进制文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> run</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> go = <span class="keyword">new</span> Go()</span><br><span class="line">    <span class="keyword">const</span> &#123; instance &#125; = <span class="keyword">await</span> WebAssembly.instantiateStreaming(fetch(<span class="string">"test.wasm"</span>), go.importObject)</span><br><span class="line">    run = go.run(instance)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>通过输入框和按钮来替换我们的<code>Run</code>按钮来触发<code>printMessage()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"messageInput"</span> type=<span class="string">"text"</span> value=<span class="string">"Hello Wasm!"</span>&gt;</span><br><span class="line">&lt;button </span><br><span class="line">        onClick=<span class="string">"printMessage(document.querySelector('#messageInput').value)"</span> </span><br><span class="line">        id=<span class="string">"printMessageButton"</span> </span><br><span class="line">        disabled</span><br><span class="line">&gt;</span><br><span class="line">    Print message</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>接收和存储回调的<code>setPrintMessage()</code>函数变得简单了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printMessage</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPrintMessage</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    printMessage = callback</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#printMessageButton'</span>).disabled = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当点击<code>Print message</code>按钮时，应该看到输入的信息和计数器输出在<code>console</code>中。然后，如果勾选浏览器控制台的<code>Preserve log</code>选项并刷新页面，则应该在<code>console</code>中看到<code>Bye Wasm !</code>。</p><p><a href="https://github.com/0x5010/example/tree/master/wasm/long_running" target="_blank" rel="noopener">完整代码</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上面用简单的例子和较少的代码测试了<code>syscall/js</code>API，<code>Go</code>与<code>js</code>之间更容易的相互调用了。如果感兴趣的可以做一些基准测试比较下<code>Go</code>的<code>wasm</code>与等效的纯<code>js</code>代码的性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.keyboardman.me/2018/06/27/managing-project-env-u
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="webassembly" scheme="http://blog.keyboardman.me/tags/webassembly/"/>
    
  </entry>
  
  <entry>
    <title>使用direnv来独立项目环境</title>
    <link href="http://blog.keyboardman.me/2018/06/27/managing-project-env-using-direnv/"/>
    <id>http://blog.keyboardman.me/2018/06/27/managing-project-env-using-direnv/</id>
    <published>2018-06-27T03:28:36.978Z</published>
    <updated>2018-06-28T07:20:06.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近<code>Web Assembly</code>（简称<code>wasm</code>）特性合并到了<code>go</code>主分支上，想尝试一下，但又不想直接把本机的<code>go</code>直接升级成<code>devel</code>版本，于是找到了<code>direnv</code>来独立一个<code>go</code>环境来测试<code>wasm</code>。</p><p><a href="https://github.com/direnv/direnv" target="_blank" rel="noopener">direnv</a>是<code>shell</code>的环境切换器。它知道如何挂钩<code>bash</code>，<code>zsh</code>，<code>tcsh</code>，<code>fish</code>和<code>elvish</code>，以根据当前目录加载或卸载环境变量。这允许项目特定的环境变量而不会混淆<code>~/.profile</code>文件。</p><p>在每次提示之前，<code>direnv</code>检查当前目录和父目录中是否存在<code>.envrc</code>文件。如果该文件存在（并且已被<code>allow</code>），则将其加载到子<code>shell</code>中，然后所有导出的变量将被<code>direnv</code>捕获，然后提供给当前<code>shell</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过源码安装需要<code>go</code>版本大于<code>1.9</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/direnv/direnv</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/direnv/direnv</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>或使用常见的包管理软件安装，如在<code>mac</code>上使用<code>brew</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install direnv</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="配置shell"><a href="#配置shell" class="headerlink" title="配置shell"></a>配置shell</h3><p>如<code>zsh</code>在<code>~/.zshrc</code>文件的末尾添加以下行：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">"$(direnv hook zsh)"</span></span><br></pre></td></tr></table></figure></p><p>其他类似，根据文档添加相应的配置。</p><h3 id="配置目标目录"><a href="#配置目标目录" class="headerlink" title="配置目标目录"></a>配置目标目录</h3><p>在目标文件夹中，创建一个<code>.envrc</code>文件并在其中添加一些<code>export</code>指令。请注意，<code>.envrc</code>文件的内容必须是有效的<code>bash</code>语法，无论您使用的是何种<code>shell</code>。这是因为<code>direnv</code>总是用<code>bash</code>执行<code>.envrc</code>，这样<code>direnv</code>可以在<code>shell</code>中工作。如果尝试使用某些在<code>bash</code>中不起作用的语法（如<code>zsh</code>的嵌套扩展），会有问题。</p><p>编辑完<code>.envrc</code>会看到<code>direnv</code>警告<code>direnv: error .envrc is blocked.</code>。这是避免自动加载新文件的安全机制，需要手动执行<code>direnv allow</code>批准记载并看到<code>direnv</code>加载新环境。请注意，<code>direnv edit .</code>是一个快捷方式，可以在<code>$EDITOR</code>中打开文件，并在文件被修改自动<code>allow</code>该文件。</p><p>进入对应目录，环境自动加载，一旦你从目录中移出，它会自动卸载。如果回到它，它再次被加载。直接进入子目录也会加载。</p><p>简单测试下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/project</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"echo 'test direnv'"</span> &gt;&gt; .envrc</span><br><span class="line">direnv allow</span><br></pre></td></tr></table></figure></p><p>那么再你再进入这个目录时，就会输出<code>test direnv</code>。</p><h3 id="stdlib"><a href="#stdlib" class="headerlink" title="stdlib"></a><code>stdlib</code></h3><p>手动<code>export</code>变量有点麻烦，<code>direnv</code>提供了些实用的函数可以方便的编写<code>.envrc</code>，输入<code>direnv stdlib</code>或在<a href="https://github.com/direnv/direnv/blob/master/stdlib.sh" target="_blank" rel="noopener">stdlib.sh</a>查看。也可以通过在<code>~/.config/direnv/direnvrc</code>或<code>~/.direnvrc</code>中创建一个<code>bash</code>文件来创建自己的扩展函数。创建一个独立的go环境只要在想要的目录下添加<code>.envrc</code>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout <span class="keyword">go</span></span><br></pre></td></tr></table></figure><h3 id="加载分层的-envrc"><a href="#加载分层的-envrc" class="headerlink" title="加载分层的.envrc"></a>加载分层的<code>.envrc</code></h3><p>假设你有以下结构：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── a</span><br><span class="line">    ├── .envrc</span><br><span class="line">    └── b</span><br><span class="line">        └── .envrc</span><br></pre></td></tr></table></figure></p><p>进入子目录<code>b</code>时只有<code>b</code>下的<code>.envrc</code>会生效，可以在文件里添加<code>source_env ..</code>或<code>source_up</code>来同时加载对应目录或更高级目录的<code>.envrc</code>。</p><h2 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h2><p>使用源码安装特定的<code>go</code>版本，该版本的<code>go</code>就编译好在<code>/your/path/go/bin</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /your/path/</span><br><span class="line">git <span class="built_in">clone</span> https://go.googlesource.com/go</span><br><span class="line"><span class="built_in">cd</span> go</span><br><span class="line"><span class="comment"># 添加有需要特性的remote，切换到到对应的版本（分支），非必要</span></span><br><span class="line"><span class="comment"># git remote add neelance https://github.com/neelance/go</span></span><br><span class="line"><span class="comment"># git fetch --all</span></span><br><span class="line"><span class="comment"># git checkout wasm-wip  # 该分支当前已经合并到主分支上</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./all.bash</span><br></pre></td></tr></table></figure></p><p>然后创建新的<code>GOPATH</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .envrc</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br></pre></td></tr></table></figure><p>并编辑<code>.envrc</code>文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH_add /your/path/<span class="keyword">go</span>/bin</span><br><span class="line">export GOROOT=<span class="string">"/your/path/go"</span></span><br><span class="line"></span><br><span class="line">layout <span class="keyword">go</span></span><br></pre></td></tr></table></figure><p><code>go version</code>查看下版本，可以看到是<code>devel</code>版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version devel +b080abf656 Tue Jun 26 01:57:01 2018 +0000 darwin/amd64</span><br></pre></td></tr></table></figure><p>在<code>src</code>创建项目目录并创建<code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Hello World, from wasm+Go"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以拷贝源码里的<code>misc/wasm</code>下文件到同目录，只需要构建一个名为<code>test.wasm</code>的文件，我们就可以重用<code>wasm_exec.html</code>和<code>wasm_exec.js</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOARCH=wasm GOOS=js go build -o test.wasm main.go</span><br></pre></td></tr></table></figure><p>开启个静态服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">addr := flag.String(<span class="string">"addr"</span>, <span class="string">":8000"</span>, <span class="string">"server address:port"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line">srv := http.FileServer(http.Dir(<span class="string">"."</span>))</span><br><span class="line">log.Printf(<span class="string">"listening on %q..."</span>, *addr)</span><br><span class="line">log.Fatal(http.ListenAndServe(*addr, srv))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并访问<code>wasm_exec.html</code>，点击按钮可以看到<code>console</code>输出了<code>Hello World, from wasm+Go</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;最近&lt;code&gt;Web Assembly&lt;/code&gt;（简称&lt;code&gt;wasm&lt;/code&gt;）特性合并到了&lt;code&gt;go&lt;/code&gt;主
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="webassembly" scheme="http://blog.keyboardman.me/tags/webassembly/"/>
    
      <category term="direnv" scheme="http://blog.keyboardman.me/tags/direnv/"/>
    
  </entry>
  
  <entry>
    <title>go中的nil</title>
    <link href="http://blog.keyboardman.me/2018/05/12/nil-in-go/"/>
    <id>http://blog.keyboardman.me/2018/05/12/nil-in-go/</id>
    <published>2018-05-12T12:08:53.698Z</published>
    <updated>2018-06-29T14:35:31.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是nil"><a href="#什么是nil" class="headerlink" title="什么是nil"></a>什么是nil</h2><p><code>nil</code>是Go中熟悉且重要的预先标识的标识符。它是多种类型的零值的字面表示。许多具有某些其他流行语言经验的新Go程序员可能会将null视为其他语言中null（或NULL）的副本。这在一定程度上是正确的，但Go中的<code>nil</code>与其他语言中的<code>null</code>(或<code>None</code>)之间存在许多差异。</p><p><code>nil</code>是预先声明的标识符，你可以使用nil而不用声明它。注意<code>nil</code>不是关键字，可以作为变量名并去改变<code>nil</code>的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="literal">nil</span> := <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="literal">nil</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认零值与默认类型"><a href="#默认零值与默认类型" class="headerlink" title="默认零值与默认类型"></a>默认零值与默认类型</h3><p>在Go语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ <span class="keyword">bool</span>   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="keyword">string</span> <span class="comment">// ""</span></span><br></pre></td></tr></table></figure><p><code>nil</code>可以代表许多类型的零值。在Go中，<code>nil</code>可以表示(<code>pointer</code>(including type-unsafe),<code>map</code>,<code>slice</code>,<code>function</code>,<code>channel</code>,<code>interface</code>)类型的零值，<code>*new(T)</code>也等于<code>nil</code>。换句话说，在Go中，<code>nil</code>可能是许多不同类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ *<span class="keyword">struct</span>&#123;&#125;    <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">var</span> _ []<span class="keyword">int</span>        <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span> <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="keyword">chan</span> <span class="keyword">string</span>  <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="function"><span class="keyword">func</span><span class="params">()</span>       // <span class="title">nil</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> _ <span class="title">interface</span></span>&#123;&#125;  <span class="comment">// nil</span></span><br><span class="line"></span><br><span class="line">_ = *<span class="built_in">new</span>(*<span class="keyword">int</span>)         <span class="comment">// nil</span></span><br><span class="line">_ = *<span class="built_in">new</span>([]<span class="keyword">int</span>)        <span class="comment">// nil</span></span><br><span class="line">_ = *<span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>) <span class="comment">// nil</span></span><br><span class="line">_ = *<span class="built_in">new</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)  <span class="comment">// nil</span></span><br><span class="line">_ = *<span class="built_in">new</span>(<span class="function"><span class="keyword">func</span><span class="params">()</span>)       // <span class="title">nil</span></span></span><br><span class="line"><span class="function">_ = *<span class="title">new</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span>  // <span class="title">nil</span></span></span><br></pre></td></tr></table></figure><p>Go中的每个其他预定义标识符都有一个默认类型。但是<code>nil</code>没有默认类型，尽管它有很多可能的类型。编译器必须有足够的信息来从上下文中推导出<code>nil</code>的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_ = <span class="number">1</span>    <span class="comment">// int</span></span><br><span class="line">_ = <span class="literal">true</span> <span class="comment">// bool</span></span><br><span class="line"></span><br><span class="line">_ = (*<span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)</span><br><span class="line">_ = []<span class="keyword">int</span>(<span class="literal">nil</span>)</span><br><span class="line">_ = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>(<span class="literal">nil</span>)</span><br><span class="line">_ = <span class="keyword">chan</span> <span class="keyword">string</span>(<span class="literal">nil</span>)</span><br><span class="line">_ = (<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(<span class="literal">nil</span>)</span></span></span><br><span class="line"><span class="function">_ = <span class="title">interface</span></span>&#123;&#125;(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="nil的大小"><a href="#nil的大小" class="headerlink" title="nil的大小"></a>nil的大小</h3><p>一个类型的所有值的内存布局总是相同的。类型的<code>nil</code>值不是例外。<code>nil</code>的大小总是与类型相同的非零值的大小相同。因此，表示不同类型的<code>nil</code>可能具有不同的大小(大小是编译器和架构相关的，以下是64位机器和标准Go编译器的结果)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(p)) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(s)) <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span> = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(m)) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">string</span> = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(c)) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span> = <span class="title">nil</span></span></span><br><span class="line"><span class="function"><span class="title">fmt</span>.<span class="title">Println</span><span class="params">(unsafe.Sizeof(f)</span>) // 8</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">i</span> <span class="title">interface</span></span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(i)) <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><h3 id="nil的对比"><a href="#nil的对比" class="headerlink" title="nil的对比"></a>nil的对比</h3><p>两个不同类型的<code>nil</code>可能不可对比。在Go中，只有两个不同的可比较类型的两个值只能在其中一个可以隐式转换为另一个类型时才能进行比较。具体而言，有三种情况可以比较两种不同可比较的两种值，<code>nil</code>也遵循同样的规则。</p><ol><li>两个值中的一个的类型是另一个的基础类型。 </li><li>两个值之一的类型实现另一个值的类型（必须是<code>interface</code>类型）。 </li><li>两个值中的一个的类型是定向<code>channel</code>类型，另一个是双向<code>channel</code>类型，且具有相同的元素类型，并且两种类型中的一种不是定义的类型。 </li></ol><p>注意如果比较的两个<code>nil</code>之一是一个<code>interface</code>，另一个不是，那么比较结果总是<code>false</code>。原因是在进行比较之前，非<code>interface</code>值将被转换为<code>interface</code>值的类型。转换的<code>interface</code>值具有一个具体的动态类型，但另一个<code>interface</code>值没有。这就是为什么比较结果总是<code>false</code>的原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntPtr *<span class="keyword">int</span></span><br><span class="line"><span class="comment">// IntPtr的基础类型是* int</span></span><br><span class="line"><span class="keyword">var</span> _ = IntPtr(<span class="literal">nil</span>) == (*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go中的每种类型都实现了interface &#123;&#125;类型</span></span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">interface</span>&#123;&#125;)(<span class="literal">nil</span>) == (*<span class="keyword">int</span>)(<span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定向channel类型的值可以转换为具有相同元素类型的双向channel类型</span></span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>) == (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这些无法编译通过，无法隐式转换</span></span><br><span class="line"><span class="keyword">var</span> _ = (*<span class="keyword">int</span>)(<span class="literal">nil</span>) == (*<span class="keyword">bool</span>)(<span class="literal">nil</span>)         <span class="comment">// error: mismatched types *int and *bool.</span></span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">chan</span> <span class="keyword">bool</span>)(<span class="literal">nil</span>) <span class="comment">// error: mismatched types chan int and chan bool.</span></span><br></pre></td></tr></table></figure><p>在Go中，<code>map</code>、<code>slice</code>和<code>function</code>类型不支持比较。因此，比较使用任何类型的不可比类型指定的两个<code>nil</code>是非法的。但是这些类型的任何值都可以与<code>nil</code>标识符进行比较。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这些无法编译通过</span></span><br><span class="line"><span class="keyword">var</span> _ = ([]<span class="keyword">int</span>)(<span class="literal">nil</span>) == ([]<span class="keyword">int</span>)(<span class="literal">nil</span>)                   <span class="comment">// error: slice can only be compared to nil.</span></span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>) <span class="comment">// error: map can only be compared to nil.</span></span><br><span class="line"><span class="keyword">var</span> _ = (<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(<span class="literal">nil</span>)</span> == <span class="params">(<span class="keyword">func</span>()</span>)<span class="params">(<span class="literal">nil</span>)</span>                 // <span class="title">error</span>: <span class="title">func</span> <span class="title">can</span> <span class="title">only</span> <span class="title">be</span> <span class="title">compared</span> <span class="title">to</span> <span class="title">nil</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 以下几行可以编译</span></span><br><span class="line"><span class="function"><span class="title">var</span> _ = <span class="params">([]<span class="keyword">int</span>)</span><span class="params">(<span class="literal">nil</span>)</span> == <span class="title">nil</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> _ = <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><span class="params">(<span class="literal">nil</span>)</span> == <span class="title">nil</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> _ = <span class="params">(<span class="keyword">func</span>()</span>)<span class="params">(<span class="literal">nil</span>)</span> == <span class="title">nil</span></span></span><br></pre></td></tr></table></figure><h2 id="nil的使用"><a href="#nil的使用" class="headerlink" title="nil的使用"></a>nil的使用</h2><p>在了解了什么是nil之后，再来说说<code>nil</code>的使用场景。</p><h3 id="pointers"><a href="#pointers" class="headerlink" title="pointers"></a>pointers</h3><p>指针表示指向内存的地址，如果对为<code>nil</code>的指针进行解引用的话就会导致<code>panic</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">p == <span class="literal">nil</span>    <span class="comment">// true</span></span><br><span class="line">*p          <span class="comment">// panic: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure><p>那么为nil的指针有什么用呢？先来看一个计算二叉树和的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">  v <span class="keyword">int</span></span><br><span class="line">  l *tree</span><br><span class="line">  r *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first solution</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  sum := t.v</span><br><span class="line">  <span class="keyword">if</span> t.l != <span class="literal">nil</span> &#123;</span><br><span class="line">    sum += t.l.Sum()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> t.r != <span class="literal">nil</span> &#123;</span><br><span class="line">    sum += t.r.Sum()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码有两个问题，一个是代码重复：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">  v.m()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个是当t是nil的时候会panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t *tree</span><br><span class="line">sum := t.Sum()   <span class="comment">// panic: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure><p>怎么解决上面的问题？我们先来看看一个指针接收器的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">(p *person)</span></span> &#123; fmt.Println(<span class="string">"hi"</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">"hi"</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> p *person</span><br><span class="line">p.sayHi() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure><p>对于指针对象的方法来说，就算指针的值为nil也是可以调用的，基于此，我们可以对刚刚计算二叉树和的例子进行一下改造：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t.v + t.l.Sum() + t.r.Sum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟刚才的代码一对比是不是简洁了很多？对于nil指针，只需要在方法前面判断一下就ok了，无需重复判断。换成打印二叉树的值或者查找二叉树的某个值都是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t *tree)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(t.l, t.v, t.r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nil receivers are useful: Find</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Find</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t.v == v || t.l.Find(v) || t.r.Find(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果不是很需要的话，不要用NewX()去初始化值，而是使用它们的默认值。</p><h3 id="slices"><a href="#slices" class="headerlink" title="slices"></a>slices</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil slices</span></span><br><span class="line"><span class="keyword">var</span> s []T</span><br><span class="line"><span class="built_in">len</span>(s) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cap</span>(s) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line">&#125; <span class="comment">// iterates zero times</span></span><br><span class="line">s[i] <span class="comment">// panic: index out of range</span></span><br></pre></td></tr></table></figure><p>一个为<code>nil</code>的<code>slice</code>，除了不能索引外，其他的操作都是可以的，<code>slice</code>有三个元素，分别是长度、容量、指向数组的指针，当你需要填充值的时候可以使用<code>append</code>函数，<code>slice</code>会自动进行扩充。所以我们并不需要担心<code>slice</code>的大小，使用<code>append</code>的话<code>slice</code>会自动扩容。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil maps</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[T1]T2</span><br><span class="line"><span class="built_in">len</span>(m) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> m &#123;</span><br><span class="line">&#125; <span class="comment">// 迭代0次</span></span><br><span class="line">v, ok := m[t1] <span class="comment">// T2的零值, false</span></span><br><span class="line">m[t1] = x      <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure><p>对于<code>nil</code>的<code>map</code>，我们可以简单把它看成是一个只读的<code>map</code>，不能进行写操作，否则就会<code>panic</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGet</span><span class="params">(url <span class="keyword">string</span>, headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(*http.Request, error)</span></span> &#123;</span><br><span class="line">  req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> headers &#123;</span><br><span class="line">    req.Header.Set(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于NewGet来说，我们需要传入一个类型为map的参数，并且这个函数只是对这个参数进行读取，我们可以传入一个非空的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="string">"USER_AGENT"</span>: <span class="string">"golang/gopher"</span>,</span><br><span class="line">&#125;,)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为空时</span></span><br><span class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map的零值是nil，所以当header为空的时候，我们也可以直接传入一个nil：</span></span><br><span class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil channels</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送和接受都会永久阻塞</span></span><br><span class="line">&lt;-ch</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ch)  <span class="comment">// panic: runtime error: close of nil channel</span></span><br></pre></td></tr></table></figure><p>这可能起初看起来并不是很有用，如果在使用之前忘记使用<code>make</code>初始化<code>channel</code>。然而，这个属性可以用一些聪明的方式来利用，特别是当你需要在<code>select</code>语句中动态地禁用一个<code>case</code>时。举个例子，假如现在有两个<code>channel</code>负责输入，一个<code>channel</code>负责汇总，简单的实现代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> v := &lt;-a:</span><br><span class="line">        out &lt;- v</span><br><span class="line">      <span class="keyword">case</span> v := &lt;- b:</span><br><span class="line">        out &lt;- v</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在外部调用中关闭了<code>a</code>或者<code>b</code>，那么就会不断地从<code>a</code>或者<code>b</code>中读出0，因为从一个关闭的<code>channel</code>接收会得到<code>channel</code>类型的零值。在我们的例子中, 类型是<code>int</code>, 所以值是 0，这和我们想要的不一样，我们想关闭a和b后就停止汇总了。</p><p>首先使用<code>v, ok</code>语法。当使用这个语法时，<code>ok</code>是一个布尔值，<code>channel</code>是开着的，它为<code>true</code>。这样可以避免将多余的零值发送给<code>out</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;- c</span><br></pre></td></tr></table></figure><p>然后正如开头提到的那样, 从<code>nil channels</code>接收数据会永远阻塞。所以在知道<code>channel</code>关闭后，为了禁用一个从<code>channel</code>接收数据的<code>case</code>, 我们可以简单将 <code>channel</code>设置为<code>nil</code> 。修改一下代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> a != <span class="literal">nil</span> || b != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> v, ok := &lt;-a:</span><br><span class="line">          <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            a = <span class="literal">nil</span></span><br><span class="line">            fmt.Println(<span class="string">"a is nil"</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">          &#125;</span><br><span class="line">          out &lt;- v</span><br><span class="line">      <span class="keyword">case</span> v, ok := &lt;-b:</span><br><span class="line">          <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            b = <span class="literal">nil</span></span><br><span class="line">            fmt.Println(<span class="string">"b is nil"</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">          &#125;</span><br><span class="line">          out &lt;- v</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"close out"</span>)</span><br><span class="line">  <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p><code>interface</code>并不是一个指针，它的底层实现由两部分组成，一个是类型，一个值，也就是类似于：<code>(Type, Value)</code>。只有当类型和值都是<code>nil</code>的时候，才等于<code>nil</code>。看看下面的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;   <span class="comment">// error(*doError, nil)</span></span><br><span class="line">  <span class="keyword">var</span> err *doError</span><br><span class="line">  <span class="keyword">return</span> err  <span class="comment">// nil of type *doError</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := do()</span><br><span class="line">  fmt.Println(err == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果是false。do函数声明了一个<code>*doErro</code>的变量<code>err</code>，然后返回，返回值是<code>error``interface</code>，但是这个时候的<code>Type</code>已经变成了：<code>(*doError，nil)</code>，所以和<code>nil</code>肯定是不会相等的。所以我们在写函数的时候，不要声明具体的error变量，而是应该直接返回<code>nil</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是nil&quot;&gt;&lt;a href=&quot;#什么是nil&quot; class=&quot;headerlink&quot; title=&quot;什么是nil&quot;&gt;&lt;/a&gt;什么是nil&lt;/h2&gt;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt;是Go中熟悉且重要的预先标识的标识符。它是多种类型的零值的字面表示。许多具有
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="nil" scheme="http://blog.keyboardman.me/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>go中的monkey patch</title>
    <link href="http://blog.keyboardman.me/2018/04/22/monkey-patch-in-go/"/>
    <id>http://blog.keyboardman.me/2018/04/22/monkey-patch-in-go/</id>
    <published>2018-04-22T14:55:14.191Z</published>
    <updated>2018-04-22T14:55:14.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>monkey patch(猴子补丁)是一种在不改变原始源代码的情况下扩展或修改动态语言的运行时代码的方法。许多人认为猴子修补只限于Python等动态语言。但事实并非如此，我们可以在运行时来修改Go函数。主角就是<a href="https://github.com/bouk/monkey" target="_blank" rel="noopener">github.com/bouk/monkey</a>。</p><p>猴子补丁主要有以下几个用处：</p><ul><li>在运行时替换方法、属性等</li><li>在不修改第三方代码的情况下增加原来不支持的功能</li><li>在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加</li><li>增加钩子，在执行某个方法的同时执行一些其他的处理，如打印日志，实现AOP等。</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><code>monkey</code>库通过修改内存地址的方式，替换目标函数的实际执行地址，实现（几乎）任意函数的<code>mock</code>。你可以指定目标函数，然后定义一个匿名函数替换掉它。替换的记录会存在一个全局表里，不需要的时候可以通过它重新恢复原来的目标函数。</p><p>先看一个官方示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/bouk/monkey"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">monkey.Patch(fmt.Println, <span class="function"><span class="keyword">func</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">s[i] = strings.Replace(fmt.Sprint(v), <span class="string">"hell"</span>, <span class="string">"*bleep*"</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Fprintln(os.Stdout, s...)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"what the hell?"</span>)  <span class="comment">// what the *bleep*?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出调用<code>fmt.Println</code>已经替换成我们patch的方法了。</p><p>有时候在我们不仅要<code>mock</code>函数，而且在patch方法里还需要调用原来的函数。这时候需要使用<code>monkey</code>库提供的 <code>PatchGuard</code>结构体。关键在于，调用原来的函数之前先调用一次<code>Unpatch</code>，恢复到<code>mock</code>之前的情况；然后在调用了原函数之后，调用一次<code>Restore</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/bouk/monkey"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> guard *monkey.PatchGuard</span><br><span class="line">guard = monkey.Patch(fmt.Println, <span class="function"><span class="keyword">func</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">s[i] = strings.Replace(fmt.Sprint(v), <span class="string">"hell"</span>, <span class="string">"*bleep*"</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消patch</span></span><br><span class="line">guard.Unpatch()</span><br><span class="line"><span class="keyword">defer</span> guard.Restore()</span><br><span class="line"><span class="comment">// 使用默认的fmt.Println</span></span><br><span class="line"><span class="keyword">return</span> fmt.Println(s...)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"what the hell?"</span>)  <span class="comment">// what the *bleep*?</span></span><br><span class="line">fmt.Println(<span class="string">"what the hell?"</span>)  <span class="comment">// what the *bleep*?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用第三方库来替换标准库，且不大范围修改原来代码，比如用<code>json-iterator</code>替换<code>encoding/json</code>来提升json的解析性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/bouk/monkey"</span></span><br><span class="line">jsoniter <span class="string">"github.com/json-iterator/go"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">ID   <span class="keyword">string</span> <span class="string">`json:"id"`</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">monkey.Patch(json.Marshal, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"use jsoniter marshal"</span>)</span><br><span class="line"><span class="keyword">return</span> jsoniter.Marshal(v)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">monkey.Patch(json.Unmarshal, <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"use jsoniter unmarshal"</span>)</span><br><span class="line"><span class="keyword">return</span> jsoniter.Unmarshal(data, v)</span><br><span class="line">&#125;)</span><br><span class="line">u1 := &amp;user&#123;</span><br><span class="line">ID:   <span class="string">"1"</span>,</span><br><span class="line">Name: <span class="string">"0x5010"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u2 := &amp;user&#123;&#125;</span><br><span class="line"></span><br><span class="line">v, err := json.Marshal(u1)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(v), err)</span><br><span class="line"></span><br><span class="line">err = json.Unmarshal(v, u2)</span><br><span class="line">fmt.Println(u2, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use jsoniter marshal</span><br><span class="line">&#123;<span class="string">"id"</span>:<span class="string">"1"</span>,<span class="string">"name"</span>:<span class="string">"0x5010"</span>&#125; &lt;nil&gt;</span><br><span class="line">use jsoniter unmarshal</span><br><span class="line">&amp;&#123;1 0x5010&#125; &lt;nil&gt;</span><br></pre></td></tr></table></figure></p><p>注意Go中虽然没有<code>inline</code>关键字，但仍存在<code>inline</code>函数，一个函数是否是<code>inline</code>函数由编译器决定。<code>inline</code>函数的特点是简单短小，在源代码的层次看有函数的结构，而在编译后却不具备函数的性质。<code>inline</code>函数不是在调用时发生控制转移，而是在编译时将函数体嵌入到每一个调用处，所以<code>inline</code>函数在调用时没有地址。通过命令行参数<code>-gcflags=-l</code>禁止<code>inline</code>，避免结果不符合预期。</p><p>如果想了解实现原理可以看作者的<a href="https://bou.ke/blog/monkey-patching-in-go/" target="_blank" rel="noopener">blog</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;monkey patch(猴子补丁)是一种在不改变原始源代码的情况下扩展或修改动态语言的运行时代码的方法。许多人认为猴子修补只限于Pytho
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go与堆</title>
    <link href="http://blog.keyboardman.me/2018/03/30/go-and-heap/"/>
    <id>http://blog.keyboardman.me/2018/03/30/go-and-heap/</id>
    <published>2018-03-30T07:01:50.507Z</published>
    <updated>2018-03-30T07:18:40.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆(heap)又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。回忆一下，在队列中，我们可以进行的限定操作是进队列和出队列。出队列是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。</p><p>堆的一个经典的实现是完全二叉树(complete binary tree)。这样实现的堆成为二叉堆(binary heap)。完全二叉树是增加了限定条件的二叉树。假设一个二叉树的深度为n。为了满足完全二叉树的要求，该二叉树的前n-1层必须填满，第n层也必须按照从左到右的顺序被填满</p><h2 id="container-heap"><a href="#container-heap" class="headerlink" title="container/heap"></a><code>container/heap</code></h2><p>包<a href="https://golang.org/pkg/container/heap/" target="_blank" rel="noopener"><code>container/heap</code></a>为所有实现了<code>heap.Interface</code>的类型提供堆操作。一个堆即是一棵树，这棵树的每个节点的值都比它的子节点的值要小，而整棵树最小的值位于树根<code>root</code>，也即是索引0的位置上。</p><h3 id="Fix-函数"><a href="#Fix-函数" class="headerlink" title="Fix 函数"></a>Fix 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fix</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>在索引i上的元素的值发生变化之后，重新修复堆的有序性。先修改索引i上的元素的值然后再执行<code>Fix</code>，跟先调用<code>Remove(h, i)</code>然后再使用 Push 操作将新值重新添加到堆里面的做法具有同等的效果，但前者所需的计算量稍微要少一些。</p><p><code>Fix</code>函数的复杂度为<code>O(log(n))</code>，其中n等于<code>h.Len()</code>。</p><h3 id="Init-函数"><a href="#Init-函数" class="headerlink" title="Init 函数"></a>Init 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(h Interface)</span></span></span><br></pre></td></tr></table></figure><p>在执行任何堆操作之前，必须对堆进行初始化。<code>Init</code>操作对于堆不变性（invariants）具有幂等性，无论堆不变性是否有效，它都可以被调用。</p><p><code>Init</code>函数的复杂度为<code>O(n)</code>，其中 n 等于<code>h.Len()</code>。</p><h3 id="Pop-函数"><a href="#Pop-函数" class="headerlink" title="Pop 函数"></a>Pop 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Pop</code>函数根据<code>Less</code>的结果，从堆中移除并返回具有最小值的元素，等同于执行<code>Remove(h, 0)</code>。</p><p><code>Pop</code>函数的复杂度为<code>O(log(n))</code>， 其中n等于<code>h.Len()</code>。</p><h3 id="Push-函数"><a href="#Push-函数" class="headerlink" title="Push 函数"></a>Push 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p><code>Push</code>函数将值为x的元素推入到堆里面，该函数的复杂度为<code>O(log(n))</code>，其中n等于<code>h.Len()</code>。</p><h3 id="Remove-函数"><a href="#Remove-函数" class="headerlink" title="Remove 函数"></a>Remove 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Remove</code>函数将移除堆中索引为i的元素，该函数的复杂度为<code>O(log(n))</code>，其中 n 等于<code>h.Len()</code>。</p><h3 id="Interface-类型"><a href="#Interface-类型" class="headerlink" title="Interface 类型"></a>Interface 类型</h3><p>任何实现了<code>heap.Interface</code>接口的类型，都可以用作带有以下不变性的最小堆，（换句话说，这个堆在为空、已排序或者调用<code>Init</code> 之后，应该具有以下性质）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!h.Less(j, i) <span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; h.Len() and <span class="number">2</span>*i+<span class="number">1</span> &lt;= j &lt;= <span class="number">2</span>*i+<span class="number">2</span> and j &lt; h.Len()</span><br></pre></td></tr></table></figure></p><p>注意， 这个接口中的<code>Push</code>和<code>Pop</code>都是由<code>heap</code>包的实现负责调用的。因此用户在向堆添加元素又或者从堆中移除元素时，需要使用<code>heap.Push</code>以及<code>heap.Pop</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 将 x 添加为元素 Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 移除并返回元素 Len() - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>可以先看一下<a href="https://golang.org/pkg/container/heap/" target="_blank" rel="noopener"><code>container/heap</code>官方文档</a>的两个范例，整数堆和优先队列。整数堆是最基本的运用，优先队列在业务中是一个常用的场景。</p><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h3><p>这个是<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">leetcode</a>中的一道题，就可以利用整数堆来减少排序元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"container/heap"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// intHeap 是一个由整数组成的最小堆。</span></span><br><span class="line"><span class="keyword">type</span> intHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// Push 和 Pop 使用 pointer receiver 作为参数，</span></span><br><span class="line"><span class="comment">// 因为它们不仅会对切片的内容进行调整，还会修改切片的长度。</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// min 堆最小元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">min</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*h) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (*h)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 把前k个元素初始化到堆，此时索引0是当前第k个最大元素，也就是h.min()</span></span><br><span class="line">h := intHeap(nums[:k])</span><br><span class="line">heap.Init(&amp;h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">    <span class="comment">// 当之后的元素比h.min()小，忽略，否则pop出最小元素，push进新元素</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; h.min() &#123;</span><br><span class="line">heap.Pop(&amp;h)</span><br><span class="line">heap.Push(&amp;h, nums[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h.min()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看下提交后的排名。<br><img src="/img/go-and-heap-1.png" alt="leetcode提交详情"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;堆(heap)又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。回忆一下，在队列中，我们可以进行的限定操作是
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="head" scheme="http://blog.keyboardman.me/tags/head/"/>
    
      <category term="算法" scheme="http://blog.keyboardman.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://blog.keyboardman.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>go GraphQL实践（一）</title>
    <link href="http://blog.keyboardman.me/2018/03/21/go-graphql-i/"/>
    <id>http://blog.keyboardman.me/2018/03/21/go-graphql-i/</id>
    <published>2018-03-21T03:31:42.000Z</published>
    <updated>2018-03-21T06:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="graphql"><a href="#graphql" class="headerlink" title="graphql"></a>graphql</h2><p>相信大家对<code>GraphQL</code>早已不陌生，这一Facebook推出的接口查询语言，立志在简洁性和扩展性方面超越<code>REST</code>，并且已经被应用在很多复杂的业务场景中。<code>GraphQL</code>查询时结构化的，信息是类树结构展示的。值类型可以理解为叶子，对象类型可以理解为树干<code>GraphQL</code>是一种描述如何请求数据的语法，通常用于客户端向服务器请求数据。<code>GraphQL</code>层位于客户端和一个或多个数据源之间，按照你的指示接收客户端请求，然后获取必要的数据。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="无冗余"><a href="#无冗余" class="headerlink" title="无冗余"></a>无冗余</h4><p>发出一个<code>GraphQL</code>请求就能准确获得你想要的数据，不多不少。<code>GraphQL</code>查询总是返回可预测的结果。使用<code>GraphQL</code>的应用可以工作得又快又稳，因为控制数据的是应用，而不是服务器。</p><h4 id="减少请求"><a href="#减少请求" class="headerlink" title="减少请求"></a>减少请求</h4><p><code>GraphQL</code>查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询。典型的<code>REST API</code>请求多个资源时得载入多个url，而<code>GraphQL</code>可以通过一次请求就获取你应用所需的所有数据。这样一来，即使是比较慢的移动网络连接下，使用<code>GraphQL</code>的应用也能表现得足够迅速。</p><h4 id="强类型"><a href="#强类型" class="headerlink" title="强类型"></a>强类型</h4><p><code>GraphQL API</code>是基于类型和字段的方式进行组织的。<code>GraphQL</code>使用强类型来保证请求数据的正确性，提前声明好类型可以避免编写代码手动进行解析。它还提供了清晰的辅助性错误信息。</p><h4 id="向下兼容"><a href="#向下兼容" class="headerlink" title="向下兼容"></a>向下兼容</h4><p>给你的<code>GraphQL API</code>添加字段和类型而无需影响现有查询。老旧的字段可以废弃，从工具中隐藏。通过使用单一演进版本，<code>GraphQL API</code>使得应用始终能够使用新的特性，并鼓励使用更加简洁、更好维护的服务端代码。</p><h4 id="只是一个规范"><a href="#只是一个规范" class="headerlink" title="只是一个规范"></a>只是一个规范</h4><p><code>GraphQL</code>让你的整个应用共享一套API，而不用被限制于特定存储引擎。<code>GraphQL</code>引擎已经有多种语言实现，通过<code>GraphQL API</code>能够更好利用你的现有数据和代码。你只需要为类型系统的字段编写函数，<code>GraphQL</code>就能通过优化并发的方式来调用它们。</p><h2 id="go的实现"><a href="#go的实现" class="headerlink" title="go的实现"></a>go的实现</h2><h3 id="基础的实现和查询"><a href="#基础的实现和查询" class="headerlink" title="基础的实现和查询"></a>基础的实现和查询</h3><p><a href="https://github.com/graphql-go/graphql" target="_blank" rel="noopener"><code>graphql-go/graphql</code></a>支持查询解析器，不支持<code>GraphQL SDL</code>解析，需要自己编写完整的<code>Field</code>和<code>Schema</code>等。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/graphql-go/graphql"</span></span><br><span class="line"><span class="string">"github.com/graphql-go/handler"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">ID   <span class="keyword">string</span> <span class="string">`json:"id"`</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">map</span>[<span class="keyword">string</span>]user = <span class="keyword">map</span>[<span class="keyword">string</span>]user&#123;</span><br><span class="line"><span class="string">"1"</span>: user&#123;</span><br><span class="line">ID:   <span class="string">"1"</span>,</span><br><span class="line">Name: <span class="string">"Dan"</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"2"</span>: user&#123;</span><br><span class="line">ID:   <span class="string">"2"</span>,</span><br><span class="line">Name: <span class="string">"Lee"</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"3"</span>: user&#123;</span><br><span class="line">ID:   <span class="string">"3"</span>,</span><br><span class="line">Name: <span class="string">"Nick"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userType = graphql.NewObject(</span><br><span class="line">graphql.ObjectConfig&#123;</span><br><span class="line">Name: <span class="string">"User"</span>,</span><br><span class="line">Fields: graphql.Fields&#123;</span><br><span class="line"><span class="string">"id"</span>: &amp;graphql.Field&#123;</span><br><span class="line">Type: graphql.String,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"name"</span>: &amp;graphql.Field&#123;</span><br><span class="line">Type: graphql.String,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> queryType = graphql.NewObject(</span><br><span class="line">graphql.ObjectConfig&#123;</span><br><span class="line">Name: <span class="string">"Query"</span>,</span><br><span class="line">Fields: graphql.Fields&#123;</span><br><span class="line"><span class="string">"user"</span>: &amp;graphql.Field&#123;</span><br><span class="line">Type: userType,</span><br><span class="line">Args: graphql.FieldConfigArgument&#123;</span><br><span class="line"><span class="string">"id"</span>: &amp;graphql.ArgumentConfig&#123;</span><br><span class="line">Type: graphql.String,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">Resolve: <span class="function"><span class="keyword">func</span><span class="params">(p graphql.ResolveParams)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">idQuery, isOK := p.Args[<span class="string">"id"</span>].(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> isOK &#123;</span><br><span class="line"><span class="keyword">if</span> v, ok := data[idQuery]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema, _ = graphql.NewSchema(</span><br><span class="line">graphql.SchemaConfig&#123;</span><br><span class="line">Query: queryType,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeQuery</span><span class="params">(query <span class="keyword">string</span>, schema graphql.Schema, vars <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">graphql</span>.<span class="title">Result</span></span> &#123;</span><br><span class="line">res := graphql.Do(graphql.Params&#123;</span><br><span class="line">Schema:         schema,</span><br><span class="line">RequestString:  query,</span><br><span class="line">VariableValues: vars,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(res.Errors) &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"error: %v"</span>, res.Errors)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">query := <span class="string">`query userinfo($uid: String = "1") &#123;</span></span><br><span class="line"><span class="string">user(id: $uid)&#123;</span></span><br><span class="line"><span class="string">id</span></span><br><span class="line"><span class="string">name</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">vars := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"uid"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">r := executeQuery(query, schema, vars)</span><br><span class="line">rJSON, _ := json.Marshal(r)</span><br><span class="line">fmt.Printf(<span class="string">"%s \n"</span>, rJSON)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/0x5010/example/blob/master/graphql/user/user1/user.go" target="_blank" rel="noopener">完整代码</a></p><h3 id="http标准库"><a href="#http标准库" class="headerlink" title="http标准库"></a>http标准库</h3><p>构建http服务只需添加简单几行代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/graphql"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">res := executeQuery(r.URL.Query().Get(<span class="string">"query"</span>), schema, <span class="literal">nil</span>)</span><br><span class="line">json.NewEncoder(w).Encode(res)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/0x5010/example/blob/master/graphql/user/user2/user.go" target="_blank" rel="noopener">完整代码</a><br>我们可以运行代码，并请求一下接口<code>curl -g &#39;http://localhost:8080/graphql?query={user(id:&quot;3&quot;){name}}&#39;</code>，查看结果。</p><h3 id="使用graphql-go-handler"><a href="#使用graphql-go-handler" class="headerlink" title="使用graphql-go/handler"></a>使用<code>graphql-go/handler</code></h3><p>使用<a href="https://github.com/graphql-go/handler" target="_blank" rel="noopener"><code>graphql-go/handler</code></a>简化构建接口代码。使用<code>graphql-go/handler</code>包后不需要自定义<code>graphql.Do</code>去实现查询函数，内部已经帮你做了这些事情。之间在浏览器访问接口可以看到调试页面，可以直接在上面测试请求。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/graphql-go/handler</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := handler.New(&amp;handler.Config&#123;</span><br><span class="line">Schema:   &amp;schema,</span><br><span class="line">Pretty:   <span class="literal">true</span>,</span><br><span class="line">GraphiQL: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">http.Handle(<span class="string">"/graphql"</span>, h)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/0x5010/example/blob/master/graphql/user/user3/user.go" target="_blank" rel="noopener">完整代码</a></p><h3 id="运用于gin"><a href="#运用于gin" class="headerlink" title="运用于gin"></a>运用于<code>gin</code></h3><p>使用第三方web库时，只要实现一个<code>handler</code>的转换。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ginHandler</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">h := handler.New(&amp;handler.Config&#123;</span><br><span class="line">Schema:   &amp;schema,</span><br><span class="line">Pretty:   <span class="literal">true</span>,</span><br><span class="line">GraphiQL: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">h.ServeHTTP(c.Writer, c.Request)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">router.Any(<span class="string">"/graphql"</span>, ginHandler())</span><br><span class="line">router.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/0x5010/example/blob/master/graphql/user/user4/user.go" target="_blank" rel="noopener">完整代码</a></p><h3 id="graph-gophers-graphql-go"><a href="#graph-gophers-graphql-go" class="headerlink" title="graph-gophers/graphql-go"></a><code>graph-gophers/graphql-go</code></h3><p><a href="https://github.com/graph-gophers/graphql-go" target="_blank" rel="noopener"><code>graph-gophers/graphql-go</code></a>是一个用于快速创建严格类型的<code>GraphQL</code>服务器库，支持查询解析器和<code>GraphQL SDL</code>解析。</p><p>我们基于它来写一个demo。</p><ol><li><p>首先编写<code>GraphQL SDL</code>(Schema Definition Language) <a href="https://github.com/0x5010/example/tree/master/graphql/pets/schema" target="_blank" rel="noopener">源码</a></p><ol><li>编写<code>schema.graphql</code>也就是<code>SDL</code>文件</li><li>运行<code>go-bindata -ignore=\.go -pkg=schema -o=schema/bindata.go schema/...</code>生成go静态代码</li><li>编写<code>schema.go</code>从静态代码中生成<code>schema</code>的<code>string</code>，用于<code>graph-gophers/graphql-go</code>解析</li></ol></li><li><p>编写<code>GraphQL SDL</code>实现 <a href="https://github.com/0x5010/example/tree/master/graphql/pets/resolver" target="_blank" rel="noopener">源码</a></p><ul><li>编写<code>Resolver</code>需要的<code>query</code>方法</li><li>根据<code>query</code>需要的返回<code>type</code>实现相应的<code>type resolver</code></li><li>编写<code>Resolver</code>需要的<code>mutation</code>方法</li><li>根据<code>mutation</code>需要的<code>input</code>和返回，实现相应的数据结构和处理逻辑</li><li>对接数据的存储和修改，代码里用<code>map</code>代替 </li></ul></li><li>编写<code>GraphQL Server</code>实现 <a href="https://github.com/0x5010/example/blob/master/graphql/pets/server.go" target="_blank" rel="noopener">源码</a></li></ol><p><a href="https://github.com/0x5010/example/tree/master/graphql/pets" target="_blank" rel="noopener">完整代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;graphql&quot;&gt;&lt;a href=&quot;#graphql&quot; class=&quot;headerlink&quot; title=&quot;graphql&quot;&gt;&lt;/a&gt;graphql&lt;/h2&gt;&lt;p&gt;相信大家对&lt;code&gt;GraphQL&lt;/code&gt;早已不陌生，这一Facebook推出的接口查询语言
      
    
    </summary>
    
      <category term="graphql实践" scheme="http://blog.keyboardman.me/categories/graphql%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="graphql" scheme="http://blog.keyboardman.me/tags/graphql/"/>
    
      <category term="web" scheme="http://blog.keyboardman.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>go与ratelimit</title>
    <link href="http://blog.keyboardman.me/2018/03/14/go-and-ratelimit/"/>
    <id>http://blog.keyboardman.me/2018/03/14/go-and-ratelimit/</id>
    <published>2018-03-14T09:37:58.000Z</published>
    <updated>2018-03-14T09:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>限流是对资源访问进行控制，当访问超过承受范围的时候，我们就必须考虑限流来保证接口的可用性或者降级可用性。</p><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><h3 id="计数器法"><a href="#计数器法" class="headerlink" title="计数器法"></a>计数器法</h3><p>计数器法是限流算法里最简单也是最容易实现的一种算法。维护一个单位时间内的Counter，当单位时间已经过去则将Counter重置零。这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题。在临界时间的前一毫秒和后一毫秒都触发了最大的请求数，就会在两毫秒内发生了两倍单位时间的最大请求数量。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>如果接触过TCP协议的话，那么一定对滑动窗口这个名词不会陌生。在时间窗划分多个格子，每个格子都单独维护一个Counter，窗口每次滑动一个格子。指定时间窗最大请求数，也就是限制的时间范围内允许的最大请求数。计数器算法其实就是滑动窗口算法，只是它没有对时间窗口做进一步地划分，所以只有1格。当维护当滑动窗口的格子划分的越多，限流就会越精确。可是这种方式没有完全解决临界问题，时间窗内一小段流量可能占比特别大。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>首先，我们有一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率。而且，当桶满了之后，多余的水将会溢出。该算法保证以一个常速速率来处理请求，所以不会出现临界问题。</p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>和漏桶算法效果类似但方向相反的算法。桶一开始是空的，token（令牌）以一个固定的速率r往桶里填充，直到达到桶的容量，多余的token将会被丢弃。每当一个请求过来时，就会尝试从桶里移除一个token，如果没有token的话，请求无法通过。令牌桶还可以方便的改变速度。 一旦需要提高速率,只要按需提高放入桶中的token的速率就行了。令牌桶算法允许流量一定程度的突发，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p>令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要根据具体场景选择合适的算法。</p><h2 id="在go中的使用"><a href="#在go中的使用" class="headerlink" title="在go中的使用"></a>在go中的使用</h2><p><code>Go</code>提供了一个package(golang.org/x/time/rate)，采用令牌桶的算法实现，用来方便的对速度进行限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">limit Limit</span><br><span class="line">burst <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">mu     sync.Mutex</span><br><span class="line">tokens <span class="keyword">float64</span></span><br><span class="line">last time.Time</span><br><span class="line">lastEvent time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="keyword">int</span>)</span> *<span class="title">Limiter</span></span></span><br></pre></td></tr></table></figure><p>首先创建一个<code>rate.Limiter</code>，其有两个参数，第一个参数为允许每秒发生多少次事件，第二个参数是其缓存最大可存多少个事件。这个桶一开始容量为b，装满b个token，然后每秒往里面填充r个token。由于令牌桶中最多有b个token，所以一次最多只能允许b个事件发生，一个事件花费掉一个token。</p><p><code>rate.Limiter</code>提供三种主要的函数。</p><h3 id="Wait-WaitN"><a href="#Wait-WaitN" class="headerlink" title="Wait/WaitN"></a><code>Wait/WaitN</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Wait</span><span class="params">(ctx context.Context)</span> <span class="params">(err error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(lim *Limiter)</span> <span class="title">WaitN</span><span class="params">(ctx context.Context, n <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span></span><br></pre></td></tr></table></figure><p><code>Wait</code>是<code>WaitN(ctx, 1)</code>的简化形式。<code>WaitN</code>阻塞当前直到lim允许n个事件的发生。当没有可用或足够的事件时，将阻塞等待，推荐实际程序中使用这个方法。</p><h3 id="Allow-AllowN"><a href="#Allow-AllowN" class="headerlink" title="Allow/AllowN"></a><code>Allow/AllowN</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Allow</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(lim *Limiter)</span> <span class="title">AllowN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>Allow</code>是函数<code>AllowN(time.Now(), 1)</code>的简化函数。<code>AllowN</code>标识在时间<code>now</code>的时候，n个事件是否可以同时发生(也意思就是now的时候是否可以从令牌桶中取n个token)。适合在超出频率的时候丢弃或跳过事件的场景。</p><h3 id="Reserve-ReserveN"><a href="#Reserve-ReserveN" class="headerlink" title="Reserve/ReserveN"></a><code>Reserve/ReserveN</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Reserve</span><span class="params">()</span> *<span class="title">Reservation</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(lim *Limiter)</span> <span class="title">ReserveN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> *<span class="title">Reservation</span></span></span><br></pre></td></tr></table></figure><p><code>Reserve</code>是<code>ReserveN(time.Now(), 1)</code>的简化形式。<code>ReserveN</code>返回对象<code>Reservation</code>，用于标识调用者需要等多久才能等到n个事件发生(意思就是等多久令牌桶中至少含有n个token)。<code>Wait/WaitN</code>和<code>Allow/AllowN</code>其实就是基于其之上实现的，通过sleep等待时间和直接返回状态。如果想对事件发生的频率和等待处理逻辑更加精细的话就可以使用它。</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/time/rate"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">l := rate.NewLimiter(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">ctx := context.Background()</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="comment">// 要处理二十个事件</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">l.Wait(ctx)</span><br><span class="line"><span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(time.Since(start)) <span class="comment">// output: 7.501262697s （初始桶内5个和每秒2个token）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;限流是对资源访问进行控制，当访问超过承受范围的时候，我们就必须考虑限流来保证接口的可用性或者降级可用性。&lt;/p&gt;
&lt;h2 id=&quot;限流算法&quot;
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>尝鲜vgo</title>
    <link href="http://blog.keyboardman.me/2018/02/23/early-adopters-versioned-go/"/>
    <id>http://blog.keyboardman.me/2018/02/23/early-adopters-versioned-go/</id>
    <published>2018-02-23T08:18:16.000Z</published>
    <updated>2018-02-23T08:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，对go来说依赖包的版本控制上没有一个好的方案，当前主要有两种方式<code>Import Versioning</code>和<code>Semantic Versioning</code>。</p><ul><li>Import Versioning：<code>gopkg.in</code>网站，其实是GitHub版本变化的重定向器，你可以通过<code>gopkg.in/yaml.v1</code>和<code>gopkg.in/yaml.v2</code> 的这样的导入方式来指向Git库的不同提交版本</li><li>Semantic Versioning：制定了一个文件格式规范来描述管理vendor目录下代码的准确源和版本信息（dep、glide）</li></ul><p>前几天(2018-02-20)Russ Cox博客上介绍了他为go设计的新工具<code>vgo</code>，这是为处理软件包版本而设计的go工具的替代品，vgo即versioned go的缩写，意即带版本的go。vgo目前只能运行在go1.10之上，否则会得到<code>vgo objabi: cannot find GOMIPS</code>这样的错误。</p><p>首先安装vgo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u golang.org/x/vgo</span><br></pre></td></tr></table></figure><p>我们先尝试下，跟着<a href="https://research.swtch.com/vgo-tour" target="_blank" rel="noopener">官方示例</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="variable">$GOPATH</span>/src/hello</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/hello</span><br><span class="line">curl -sS https://swtch.com/hello.go &gt; hello.go</span><br></pre></td></tr></table></figure><p>我们看一下<code>hello.go</code>的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// import "github.com/you/hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"rsc.io/quote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(quote.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>// import &quot;github.com/you/hello&quot;</code>注释用来告诉vgo模块的“导入路径名称”应该是什么，并且使用此模块的其他软件包将用作导入标识符。<br>创建一个空的go.mod文件来标记此项目的根目录，然后编译一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &gt;go.mod</span><br><span class="line">vgo build</span><br></pre></td></tr></table></figure><p>可以看到生成可执行文件，并修改了<code>go.mod</code>的内容，自动生成了依赖关系。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module <span class="string">"github.com/you/hello"</span></span><br><span class="line"></span><br><span class="line">require <span class="string">"rsc.io/quote"</span> v1.<span class="number">5.2</span></span><br></pre></td></tr></table></figure><p><code>go.mod</code>文件包含了模块所依赖包的最小版本。如果模块没有提供一个<code>tag</code>版本。对于未命名的提交，<code>v0.0.0-yyyymmddhhmmss-commit</code>表示一个指定日期的提交。<code>go.mod</code>文件还可以实现排除和替换的版本，需手动修改<code>go.mod</code>文件。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exclude <span class="string">"rsc.io/sampler"</span> v1.<span class="number">99.99</span></span><br><span class="line"></span><br><span class="line">replace <span class="string">"rsc.io/quote"</span> v1.<span class="number">5.2</span> =&gt; <span class="string">"../quote"</span></span><br></pre></td></tr></table></figure><p>但是，最重要的变化还是终结了<code>GOPATH</code>作为Go代码工作空间的设置，由于<code>go.mod</code>文件包含了完整的模块路径并且还定义了每个使用的依赖的版本，因此包含<code>go.mod</code>文件的目录就可以被认为是一个目录树的根目录了，该目录树作用于自身的工作空间，并且和其他类似的目录彼此隔离。</p><p>vgo其他功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vgo list -m  <span class="comment"># 查看所有依赖</span></span><br><span class="line">vgo list -m -u  <span class="comment"># 查看所有依赖同时检查更新，会打印出最新版本和当前版本</span></span><br><span class="line">vgo <span class="built_in">test</span> all  <span class="comment"># 执行所有测试，包括依赖包的测试</span></span><br><span class="line">vgo <span class="built_in">test</span> http://rsc.io/sampler  <span class="comment"># 执行指定包测试</span></span><br><span class="line">vgo get -u  <span class="comment"># 更新所有依赖</span></span><br><span class="line">vgo list -t http://rsc.io/sampler  <span class="comment"># 检查指定包所有可用的版本 即tag</span></span><br><span class="line">vgo get http://rsc.io/sampler@v1.3.1  <span class="comment"># 获取指定版本，并修改go.mod</span></span><br><span class="line">vgo vendor  <span class="comment"># 退到vendor 兼容不使用vgo的用户</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>vgo在下载github仓库时，如果当前环境是未认证的账号会受到限流影响，得到如下警告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GitHub applies fairly small rate limits to unauthenticated users, and</span><br><span class="line">you appear to be hitting them. To authenticate, please visit</span><br><span class="line">https://github.com/settings/tokens and click <span class="string">"Generate New Token"</span> to</span><br><span class="line">create a Personal Access Token. The token only needs <span class="string">"public_repo"</span></span><br><span class="line">scope, but you can add <span class="string">"repo"</span> <span class="keyword">if</span> you want to access private</span><br><span class="line">repositories too.</span><br></pre></td></tr></table></figure><p>这时候需要获取github token，在github网站依次点击<code>Settings</code>-<code>Developer settings</code>-<code>Personal access tokens</code>-<code>Generate new token</code>，填写名字和勾选权限后生成token。创建或修改<code>$HOME/.netrc</code>文件，添加下行，把生成的token填写进去，就能解决了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine api.github.<span class="keyword">com</span> login YOU password TOKEN</span><br></pre></td></tr></table></figure><p>目前vgo的文档不够完善，代码也不够健壮，在生产环境可能还不适合去使用。我在测试时就遇到了些问题，比如有的<code>gopkg.in</code>仓库使用标签而不是分支来标记主要版本。当前vgo处理这些仓库会出错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"gopkg.in/natefinch/lumberjack.v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将得到如下错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"gopkg.in/natefinch/lumberjack.v2"</span>: unexpected status (https://api.github.com/repos/natefinch/lumberjack/commits?sha=v2&amp;until=2018-02-23T03%3A49%3A22Z&amp;per_page=2): 404 Not Found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">vgo: import <span class="string">"gopkg.in/natefinch/lumberjack.v2"</span>: unexpected status (https://api.github.com/repos/natefinch/lumberjack): 403 Forbidden</span><br></pre></td></tr></table></figure><p>不过vgo应该很快就会修复这些问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来，对go来说依赖包的版本控制上没有一个好的方案，当前主要有两种方式&lt;code&gt;Import Versioning&lt;/code&gt;和&lt;code&gt;Semantic Versioning&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Import Versioning：&lt;cod
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="vgo" scheme="http://blog.keyboardman.me/tags/vgo/"/>
    
  </entry>
  
  <entry>
    <title>在linux像脚本语言一样使用go</title>
    <link href="http://blog.keyboardman.me/2018/02/22/using-go-as-a-scripting-language-in-linux/"/>
    <id>http://blog.keyboardman.me/2018/02/22/using-go-as-a-scripting-language-in-linux/</id>
    <published>2018-02-22T03:16:24.000Z</published>
    <updated>2018-02-22T03:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们想使用go像脚本一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x script.go</span><br><span class="line">./script.go</span><br></pre></td></tr></table></figure><p>乍一看好像很容易实现，在<code>.go</code>文件开头添加shebang（<code>#!</code>）行就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env <span class="keyword">go</span> run</span><br></pre></td></tr></table></figure><p>但是这样运行时不能正确地将脚本错误码返回给操作系统。错误码这对于脚本来说很重要，因为错误代码是多个脚本之间相互交互和操作系统环境最常见的方式之一。</p><p>而<code>gorun</code>解决了这个问题，安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/erning/gorun</span><br><span class="line"></span><br><span class="line">cp <span class="variable">$GOPATH</span>/bin/gorun /usr/<span class="built_in">local</span>/bin  <span class="comment"># 非必要的，在注册binfmt_misc时使用gorun的绝对路径就行</span></span><br></pre></td></tr></table></figure><p>开头改成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env gorun</span><br></pre></td></tr></table></figure><p>可是还有个问题，因为Go不知道如何处理<code>#</code>开头的行。其他脚本语言没有这个问题，因为其中大多数<code>#</code>是一种指定注释的方式，但是Go注释以<code>//</code>开头，并且在调用<code>go run</code>或<code>go build</code>会产生错误。</p><p>我们中的大多数人都知道Linux（包括一些类Unix操作系统）的可执行文件是ELF二进制格式。其实Linux内核还支持更多二进制格式（用于各种二进制格式的树内模块通常在其名称中具有<code>binfmt_</code>前缀）。值得注意的是<code>binfmt_script</code>模块，它负责解析上面提到的seebang行并在目标系统上执行脚本。但shebang不是Go脚本的最佳选择，而Linux内核有一个合适的模块<code>binfmt_misc</code>。该模块可以通过定义良好的<code>procfs</code>接口直接从用户空间动态添加对各种可执行格式的支持。</p><p>根据<a href="https://www.kernel.org/doc/html/v4.14/admin-guide/binfmt-misc.html" target="_blank" rel="noopener">内核文档</a>，首先安装<code>binfmt_misc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc</span><br></pre></td></tr></table></figure><p>现在我们需要告诉<code>binfmt_misc</code>模块如何使用<code>gorun</code>来执行我们的<code>.go</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">':golang:E::go::/usr/local/bin/gorun:OC'</span> | sudo tee /proc/sys/fs/binfmt_misc/register</span><br></pre></td></tr></table></figure><p>配置字符串<code>:golang:E::go::/usr/local/bin/gorun:OC</code>，它告诉系统：“如果遇到一个带<code>.go</code>扩展名的可执行文件，请使用<code>/usr/local/bin/gorun</code>解释器执行它“。字符串末尾的OC标志确保脚本将根据脚本本身设置的所有者信息和权限位执行，而不是在解释器二进制文件上设置的那些位。这使Go脚本的执行行为与Linux中其他可执行文件和脚本的行为相同。这并没有改变<code>.go</code>文件的内容，自然可以像之前一样的<code>go run</code>和<code>go build</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时我们想使用go像脚本一样。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="linux" scheme="http://blog.keyboardman.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-连接语义和API</title>
    <link href="http://blog.keyboardman.me/2018/02/08/grpc-doc-with-grpc-connectivity-semantics-and-api/"/>
    <id>http://blog.keyboardman.me/2018/02/08/grpc-doc-with-grpc-connectivity-semantics-and-api/</id>
    <published>2018-02-08T08:51:12.000Z</published>
    <updated>2018-03-13T13:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md" target="_blank" rel="noopener">gRPC Connectivity Semantics and API</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/connectivity-semantics-and-api.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>本文档描述了gRPC通道的连接语义以及对RPC的相应影响。然后我们浅谈下API。</p><h3 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h3><p>gRPC抽象了客户端与服务器进行通信的方式。客户端通道对象可以使用多于一个DNS名称来创建。通道封装了一系列功能，包括名称解析，建立TCP连接(带有retry和backoff)以及TLS握手。通道还可以处理已建立的连接上的错误并重新连接，或者在HTTP/2 <code>GO_AWAY</code>的情况下，重新解析并重新连接。</p><p>为了对使用者隐藏gRPC API(即程序代码)的这些活动的细节，同时暴露有关信道状态的有意义的信息，用具有五种状态的状态机表示，定义如下：</p><p>CONNECTING: 该通道正在尝试建立连接，正在等待名称解析，TCP连接建立或TLS握手所涉及的其中一个步骤。这可以被用作创建时的通道的初始状态。</p><p>READY: 通道已经通过TLS握手(或相当的操作)后一直成功地建立连接，并且所有后续的通信尝试都成功(或者正在等待而没有任何已知的故障)。</p><p>TRANSIENT_FAILURE: 出现了一些暂时的故障(如TCP三次握手超时或socket错误)。此状态下的通道最终将切换到<code>CONNECTING</code>状态，并尝试再次建立连接。由于重试是以指数backoff的方式完成的，所以不能连接的信道将在这个状态下花费很少的时间，但是由于尝试重复失败，信道将花费越来越多的时间在这个状态。对于许多非致命故障(例如，由于服务器尚不可用而导致TCP连接尝试超时)，信道可能在此状态下花费越来越多的时间。</p><p>IDLE: 这是由于缺乏新的或待处理的RPC，通道甚至不尝试创建连接的状态。新的RPC可以在这个状态下创建。任何尝试在通道上启动RPC都会将通道的状态变更为CONNECTING。当一个指定<code>IDLE_TIMEOUT</code>的通道上没有RPC活动时，即在此期间没有新的或挂起的（活动）RPC时，<code>READY</code>或<code>CONNECTING</code>通道状态变更为<code>IDLE</code>。另外，当没有活动或待处理的RPC时，接收<code>GOAWAY</code>的通道也应变更到IDLE状态，以避免试图断开连接的服务器的连接超载。我们将使用300秒(5分钟)的默认<code>IDLE_TIMEOUT</code>。</p><p>SHUTDOWN: 这个通道已经开始关闭了。任何新的RPC应该立即失败。待处理的RPC可能会继续运行，直到程序取消它们。通道可能会进入此状态，因为程序明确要求关闭或在尝试连接通信期间发生了不可恢复的错误(截至2015年12月6日，没有已知的错误(连接或通信中)被归类为不可恢复)。 进入此状态的通道永远不会改变这个状态。</p><p>下表列出了从一个状态到另一个状态的转换规则以及相应的原因。<code>-</code>单元格表示不允许的转换。</p><table><thead><tr><th>From/To</th><th style="text-align:center">CONNECTING</th><th style="text-align:center">READY</th><th style="text-align:center">TRANSIENT_FAILURE</th><th style="text-align:center">IDLE</th><th style="text-align:center">SHUTDOWN</th></tr></thead><tbody><tr><td>CONNECTING</td><td style="text-align:center">在连接建立期间增量</td><td style="text-align:center">建立连接所需的所有步骤都成功了</td><td style="text-align:center">在建立连接所需的任何步骤中出现任何故障</td><td style="text-align:center">通道上没有RPC活动直到<code>IDLE_TIMEOUT</code></td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>READY</td><td style="text-align:center">-</td><td style="text-align:center">在已建立的通道上增加成功的通话</td><td style="text-align:center">预期在已建立的通道上成功通信时遇到任何故障</td><td style="text-align:center">没有活动或待处理的RPC时接收<code>GOAWAY</code>或没有待处理的RPC直到<code>IDLE_TIMEOUT</code></td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>TRANSIENT_FAILURE</td><td style="text-align:center">指数backoff重试等待时间结束</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>IDLE</td><td style="text-align:center">频道上的任何新的RPC活动</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>SHUTDOWN</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><h3 id="通道状态API"><a href="#通道状态API" class="headerlink" title="通道状态API"></a>通道状态API</h3><p>所有的gRPC库都会公开一个通道级别的API方法来轮询当前的通道状态。在C++中，这种方法称为<code>GetState</code>，并返回五个合法状态之一的枚举。如果通道当前是IDLE的，它也接受布尔<code>try_to_connect</code>转换到CONNECTING，他的行为像一个RPC发生，所以它也应该重置<code>IDLE_TIMEOUT</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">grpc_connectivity_state <span class="title">GetState</span><span class="params">(<span class="keyword">bool</span> try_to_connect)</span></span>;</span><br></pre></td></tr></table></figure></p><p>所有的库都应该公开一个API，使得程序(gRPC API的使用者)在通道状态改变时得到通知。由于状态变化可以很快并且与任何这样的通知竞争，所以通知应该只是通知使用者已经发生了一些状态改变，留给使用者轮询当前状态。</p><p>这个API的同步版本是:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WaitForStateChange</span><span class="params">(grpc_connectivity_state source_state, gpr_timespec deadline)</span></span>;</span><br></pre></td></tr></table></figure></p><p>当状态是<code>source_state</code>以外的状态时返回true，如果截止时间到期则返回false。基于异步和期货的API应该有一个相应的方法，允许在通道状态改变时通知程序。</p><p>请注意，每次从任何状态转换到其他任何状态时都会发送通知。另一方面，合法状态转换的规则，即使相应的指数回退在重试之前不需要等待，也需要从连接转换到<code>TRANSIENT_FAILURE</code>，并返回连接到每个可恢复故障。综合的影响是应用程序可能会收到虚假的状态更改通知。例如，在<code>CONNECTING</code>状态的通道上等待状态改变的应用程序可以接收状态改变通知，但是在轮询当前状态时找到处于还是<code>CONNECTING</code>状态的通道，因为该通道可能在<code>TRANSIENT_FAILURE</code>状态中花费了无限小的时间量。</p><hr><h2 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h2><p>go的实现基本同上，除了去掉了<code>try_to_connect</code>的功能。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">connectivity</span>.<span class="title">State</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cc.csMgr.getState()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">WaitForStateChange</span><span class="params">(ctx context.Context, sourceState connectivity.State)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ch := cc.csMgr.getNotifyChan()</span><br><span class="line"><span class="keyword">if</span> cc.csMgr.getState() != sourceState &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真正的功能实现在<code>connectivityStateManager</code>中。可以看到<code>ClientConn.WaitForStateChange</code>是通过新建或监听已有<code>notifyChan</code>来感知状态变化。而修改状态的函数<code>updateState</code>在修改状态后，关闭<code>notifyChan</code>来通知所有监听goroutine状态变更。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> connectivityStateManager <span class="keyword">struct</span> &#123;</span><br><span class="line">mu         sync.Mutex</span><br><span class="line">state      connectivity.State</span><br><span class="line">notifyChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">updateState</span><span class="params">(state connectivity.State)</span></span> &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> csm.state == connectivity.Shutdown &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> csm.state == state &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">csm.state = state</span><br><span class="line"><span class="keyword">if</span> csm.notifyChan != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(csm.notifyChan)</span><br><span class="line">csm.notifyChan = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">connectivity</span>.<span class="title">State</span></span> &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> csm.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">getNotifyChan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> csm.notifyChan == <span class="literal">nil</span> &#123;</span><br><span class="line">csm.notifyChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> csm.notifyChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在连接<code>connect</code>时会创建一个goroutine去监控状态变化，通过<code>handleSubConnStateChange</code>(最终调用到<code>connectivityStateManager.updateState</code>)去修改状态。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ac *addrConn)</span> <span class="title">transportMonitor</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> timer *time.Timer</span><br><span class="line"><span class="keyword">var</span> cdeadline &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">ac.mu.Lock()</span><br><span class="line">t := ac.transport</span><br><span class="line"><span class="comment">// 如果有设置截止时间则生成个定时器</span></span><br><span class="line"><span class="keyword">if</span> !ac.connectDeadline.IsZero() &#123;</span><br><span class="line">timer = time.NewTimer(ac.connectDeadline.Sub(time.Now()))</span><br><span class="line">cdeadline = timer.C</span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="comment">// 阻塞，直到我们收到`GoAway`或发生错误</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.GoAway(): <span class="comment">// GoAway</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.Error():  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cdeadline:  <span class="comment">// 超时</span></span><br><span class="line">ac.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> ac.backoffDeadline.IsZero() &#123;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line">timer = <span class="literal">nil</span></span><br><span class="line">grpclog.Warningf(<span class="string">"grpc: addrConn.transportMonitor didn't get server preface after waiting. Closing the new transport now."</span>)</span><br><span class="line">t.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> timer != <span class="literal">nil</span> &#123;</span><br><span class="line">timer.Stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果GoAway发生了，不管错误如何，适当调整我们的Keepalive参数</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.GoAway():</span><br><span class="line">ac.adjustParams(t.GetGoAwayReason())</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> ac.state == connectivity.Shutdown &#123;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在调用resetTransport之前，将连接状态设置为TransientFailure。因为无法从READY变成CONNECTING。</span></span><br><span class="line">ac.state = connectivity.TransientFailure</span><br><span class="line">ac.cc.handleSubConnStateChange(ac.acbw, ac.state)</span><br><span class="line">ac.cc.resolveNow(resolver.ResolveNowOption&#123;&#125;)</span><br><span class="line">ac.curAddr = resolver.Address&#123;&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="comment">// resetTransport将重新创建连接，把状态设置为Connecting</span></span><br><span class="line"><span class="keyword">if</span> err := ac.resetTransport(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ac.mu.Lock()</span><br><span class="line">ac.printf(<span class="string">"transport exiting: %v"</span>, err)</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line">grpclog.Warningf(<span class="string">"grpc: addrConn.transportMonitor exits due to: %v"</span>, err)</span><br><span class="line"><span class="keyword">if</span> err != errConnClosing &#123;</span><br><span class="line">ac.tearDown(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遇到错误或手动调用<code>Close</code>时，将状态设置为<code>Shutdown</code>，相关goroutine感知到状态为<code>Shutdown</code>或得到<code>errConnClosing</code>错误时自己退出。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p><p>虽然有<code>Idle</code>状态，但是却没有和doc<code>IDLE_TIMEOUT</code>和相关的实现。目前只作为负载均衡中一些连接状态的标记。</p><p>当我们想要判断一个连接是不是可用(<code>Ready</code>)状态时，可以：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">s := cc.GetState()</span><br><span class="line"><span class="keyword">if</span> s == connectivity.Ready &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !cc.WaitForStateChange(ctx, s) &#123;</span><br><span class="line"><span class="comment">// ctx got timeout or canceled.</span></span><br><span class="line"><span class="comment">// handle timeout</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;g
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-连接backoff协议</title>
    <link href="http://blog.keyboardman.me/2018/02/06/grpc-doc-with-grpc-connection-backoff/"/>
    <id>http://blog.keyboardman.me/2018/02/06/grpc-doc-with-grpc-connection-backoff/</id>
    <published>2018-02-06T02:21:01.000Z</published>
    <updated>2018-03-13T13:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md" target="_blank" rel="noopener">gRPC Connection Backoff Protocol</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/connection-backoff.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>当我们连接到一个失败的后端时，通常希望不要立即重试(以避免泛滥的网络或服务器的请求)，而是做某种形式的指数backoff。</p><p>我们有几个参数：</p><ol><li>INITIAL_BACKOFF (第一次失败重试前后需等待多久)</li><li>MULTIPLIER (在失败的重试后乘以的倍数)</li><li>JITTER (随机抖动因子).</li><li>MAX_BACKOFF (backoff上限)</li><li>MIN_CONNECT_TIMEOUT (最短重试间隔)</li></ol><h3 id="建议backoff算法"><a href="#建议backoff算法" class="headerlink" title="建议backoff算法"></a>建议backoff算法</h3><p>以指数形式返回连接尝试的起始时间，达到MAX_BACKOFF的极限，并带有抖动。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectWithBackoff()</span><br><span class="line">  current_backoff = INITIAL_BACKOFF</span><br><span class="line">  current_deadline = now() + INITIAL_BACKOFF</span><br><span class="line">  <span class="keyword">while</span> (TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT))!= SUCCESS)</span><br><span class="line">    SleepUntil(current_deadline)</span><br><span class="line">    current_backoff = Min(current_backoff * MULTIPLIER, MAX_BACKOFF)</span><br><span class="line">    current_deadline = now() + current_backoff + UniformRandom(-JITTER * current_backoff, JITTER * current_backoff)</span><br></pre></td></tr></table></figure></p><p>参数默认值<code>MIN_CONNECT_TIMEOUT</code>=20sec <code>INITIAL_BACKOFF</code>=1sec <code>MULTIPLIER</code>=1.6 <code>MAX_BACKOFF</code>=120sec <code>JITTER</code>=0.2</p><p>根据的确切的关注点实现(例如最小化手机的唤醒次数)可能希望使用不同的算法，特别是不同的抖动逻辑。</p><p>备用的实现必须确保连接退避在同一时间开始分散，并且不得比上述算法更频繁地尝试连接。</p><h3 id="重置backoff"><a href="#重置backoff" class="headerlink" title="重置backoff"></a>重置backoff</h3><p>backoff应在某个时间点重置为<code>INITIAL_BACKOFF</code>，以便重新连接行为是一致的，不管连接的是新开始的还是先前断开的连接。</p><p>当接收到<code>SETTINGS</code>帧时重置backoff，在那个时候，我们确定这个连接被服务器已经接受了。</p><hr><h2 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h2><p>源码位于<code>google.golang.org/grpc/backoff</code>，代码不多，直接在代码上分析。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应上面的默认值但是没有实现MIN_CONNECT_TIMEOUT参数</span></span><br><span class="line"><span class="keyword">var</span> DefaultBackoffConfig = BackoffConfig&#123;</span><br><span class="line">MaxDelay:  <span class="number">120</span> * time.Second,</span><br><span class="line">baseDelay: <span class="number">1.0</span> * time.Second,</span><br><span class="line">factor:    <span class="number">1.6</span>,</span><br><span class="line">jitter:    <span class="number">0.2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backoffStrategy是backoff算法的接口</span></span><br><span class="line"><span class="keyword">type</span> backoffStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过重试次数返回在下一次重试之前等待的时间量</span></span><br><span class="line">backoff(retries <span class="keyword">int</span>) time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BackoffConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">MaxDelay time.Duration</span><br><span class="line">baseDelay time.Duration</span><br><span class="line">factor <span class="keyword">float64</span></span><br><span class="line">jitter <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDefaults</span><span class="params">(bc *BackoffConfig)</span></span> &#123;</span><br><span class="line">md := bc.MaxDelay</span><br><span class="line">*bc = DefaultBackoffConfig</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> md &gt; <span class="number">0</span> &#123;</span><br><span class="line">bc.MaxDelay = md</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backoff算法的基础实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc BackoffConfig)</span> <span class="title">backoff</span><span class="params">(retries <span class="keyword">int</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> retries == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bc.baseDelay</span><br><span class="line">&#125;</span><br><span class="line">backoff, max := <span class="keyword">float64</span>(bc.baseDelay), <span class="keyword">float64</span>(bc.MaxDelay)</span><br><span class="line"><span class="keyword">for</span> backoff &lt; max &amp;&amp; retries &gt; <span class="number">0</span> &#123;</span><br><span class="line">backoff *= bc.factor</span><br><span class="line">retries--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> backoff &gt; max &#123;</span><br><span class="line">backoff = max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Randomize backoff delays so that if a cluster of requests start at</span></span><br><span class="line"><span class="comment">// the same time, they won't operate in lockstep.</span></span><br><span class="line">backoff *= <span class="number">1</span> + bc.jitter*(rand.Float64()*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> backoff &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> time.Duration(backoff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果默认的backoff算法不满足需求的时候，还可以自定义backoff算法，通过实现backoffStrategy接口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withBackoff</span><span class="params">(bs backoffStrategy)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.bs = bs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grpc.Dial(addr, grpc.withBackoff(mybackoff))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC Connecti
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-健康检查</title>
    <link href="http://blog.keyboardman.me/2018/02/05/grpc-doc-with-grpc-go-health-checking/"/>
    <id>http://blog.keyboardman.me/2018/02/05/grpc-doc-with-grpc-go-health-checking/</id>
    <published>2018-02-05T09:24:22.000Z</published>
    <updated>2018-03-13T13:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">gRPC Health Checking Protocol</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/health-checking.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>健康检查用于探测服务器是否能够处理rpc。client到server的健康状况检查可能会发生在点对点或通过某个控制系统。server可能会选择回复“不健康”，因为它没有准备好接受请求，正在关闭或其他原因。如果在一段时间内没有收到回复，或者回复内容不健康，client可以采取相应措施。</p><p>使用gRPC service作为对client到server简单场景和其他控制系统(负载均衡)的健康检查机制。作为一个高层次的service带来一些好处。首先，由于它本身是一个gRPC service，所以进行健康检查的形式与正常的rpc相同。其次，它具有丰富的语义，如每个service的健康状况。第三，作为gRPC服务，它可以重用所有现有的如计费和限制基础设施等，因此server可以完全控制健康检查service的访问。</p><h3 id="Service定义"><a href="#Service定义" class="headerlink" title="Service定义"></a>Service定义</h3><p>server由下面的proto中service定义导出：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  string service = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    SERVING = 1;</span><br><span class="line">    NOT_SERVING = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client可以通过调用<code>Check</code>方法来查询service的健康状态，并且应该在rpc上设置超时。client可以选择设置要查询健康状态的服务名称。建议的服务名称格式是<code>package_names.ServiceName</code>，比如<code>grpc.health.v1.Health</code>。</p><p>这个server应手动注册所有的service并设置各自的状态，包括空服务名称及其状态。对于收到的每个请求，如果可以在注册表中找到服务名称，则必须以<code>OK</code>状态发回响应，并且相应地将状态字段设置为<code>SERVING</code>或<code>NOT_SERVING</code>。如果服务名称未注册，则服务器返回<code>NOT_FOUND</code> GRPC状态。</p><p>server应该使用一个空字符串作为server的整体运行状况的关键字，以便对特定service不感兴趣的client可以用空请求查询服务器的状态。server可以在不支持任何通配符匹配的情况下完成对service名称的精确匹配。但是，service所有者可以自由地实现对client和server一致更复杂的匹配语义。</p><p>client如果rpc一段时间后没有完成可以宣布server不健康。client应该能够处理server没有<code>Health</code> service的情况。</p><hr><h2 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h2><p><code>grpc-go</code>本身就有实现这个server，我们可以很方便的嵌入到我们的grpc服务中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line">healthpb <span class="string">"google.golang.org/grpc/health/grpc_health_v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">pb.RegisterMyServer(s, &amp;myServer&#123;&#125;)</span><br><span class="line"><span class="comment">// add </span></span><br><span class="line">hsrv := health.NewServer()</span><br><span class="line">hsrv.SetServingStatus(<span class="string">""</span>, healthpb.HealthCheckResponse_SERVING)</span><br><span class="line">healthpb.RegisterHealthServer(s, hsrv)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>client部分跟所有正常grpc请求一样，编写下测试代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cli := healthpb.NewHealthClient(grpcConn)</span><br><span class="line">resp, err := cli.Check(context.TODO(), &amp;healthpb.HealthCheckRequest&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.Status != healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很简单就嵌入了健康检查的功能，当然client对状态的判断处理要根据实际场景情况进行相应的处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC Health Chec
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>Functional Options Patter</title>
    <link href="http://blog.keyboardman.me/2018/01/03/grpc-functional-options-patter/"/>
    <id>http://blog.keyboardman.me/2018/01/03/grpc-functional-options-patter/</id>
    <published>2018-01-03T07:57:25.000Z</published>
    <updated>2018-03-13T13:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方式都用不了。</p><p>像构造方法这是一个非常常见的用例，拿它来做例子。比方说,我们有一些名为<code>Client</code>的结构,它有一个连接和附属参数(timeout和retries)，然后我们提供一个构造方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">interface</span> &#123;</span><br><span class="line">    Do() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> client <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    Connection</span><br><span class="line">    timeout <span class="keyword">int</span></span><br><span class="line">    retries <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">Client</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;client&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: timeout,</span><br><span class="line">        retries: retries,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是每次调用NewClient时都要提供<code>timeout</code>和<code>retries</code>。而大多数时候只想使用默认值。<br>一个方法是创建另一个不同名称的构造方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection)</span> <span class="title">Client</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewClientWithOptions</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">Client</span></span></span><br></pre></td></tr></table></figure></p><p>另一种是传入了一个配置对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    Retries <span class="keyword">int</span> </span><br><span class="line">    Timeout <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection, options Options)</span> <span class="title">Client</span></span></span><br></pre></td></tr></table></figure></p><p>不够优雅，要么要写非常多的构造方法，要么需要在代码中进行额外的检查和验证或通过传递不关心的参数来为做额外判断的工作。而grpc使用的是一种干净的解决方案: Functional Options Patter。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dialOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">insecure    <span class="keyword">bool</span></span><br><span class="line">timeout     time.Duration</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DialOption <span class="function"><span class="keyword">func</span><span class="params">(*dialOptions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ClientConn</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">dopts        dialOptions</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(*ClientConn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> DialContext(context.Background(), target, opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ClientConn</code>主要附属参数在<code>dopts</code>中，构造方法<code>Dial</code>参数是可选个数的<code>DialOption</code>。是不是觉得和上面第二种没什么区别，注意传进去的<code>DialOption</code>是方法，先看看库里几个常见的方法的实现。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithInsecure</span><span class="params">()</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.insecure = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(d time.Duration)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.timeout = d</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>dialOptions</code>是可用选项，定义了一些方法<code>WithInsecure</code>和<code>WithTimeout</code>, 它们返回一个闭包函数，用来修改<code>dialOptions</code>的选项。 另外又定义了<code>DialOption</code>, 它是一个接受这些方法。接着我们来看构造方法的关键部分。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">cc := &amp;ClientConn&#123;</span><br><span class="line">target: target,</span><br><span class="line">csMgr:  &amp;connectivityStateManager&#123;&#125;,</span><br><span class="line">conns:  <span class="built_in">make</span>(<span class="keyword">map</span>[*addrConn]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line"></span><br><span class="line">blockingpicker: newPickerWrapper(),</span><br><span class="line">&#125;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// 如果想设置默认值可以 cc.dopts = DefaultDopts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(&amp;cc.dopts)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造函数遍历了DialOption列表, 并对每一项应用返回的闭包运用到的选项<code>dopts</code>。使用起来也很方便。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grpc.Dial(addr, grpc.WithInsecure())</span><br><span class="line">grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(time.Duration(<span class="number">10</span>*time.Second)))</span><br></pre></td></tr></table></figure></p><p>而且我们可以随时添加新的选项, 只需要对代码进行非常少量的更改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方
      
    
    </summary>
    
      <category term="grpc-go源码分析" scheme="http://blog.keyboardman.me/categories/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="源码分析" scheme="http://blog.keyboardman.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
