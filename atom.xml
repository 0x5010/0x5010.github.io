<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>keyboardman</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.keyboardman.me/"/>
  <updated>2018-03-14T09:41:15.000Z</updated>
  <id>http://blog.keyboardman.me/</id>
  
  <author>
    <name>0x5010</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go与ratelimit</title>
    <link href="http://blog.keyboardman.me/2018/03/14/go-and-ratelimit/"/>
    <id>http://blog.keyboardman.me/2018/03/14/go-and-ratelimit/</id>
    <published>2018-03-14T09:37:58.000Z</published>
    <updated>2018-03-14T09:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>限流是对资源访问进行控制，当访问超过承受范围的时候，我们就必须考虑限流来保证接口的可用性或者降级可用性。</p><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><h3 id="计数器法"><a href="#计数器法" class="headerlink" title="计数器法"></a>计数器法</h3><p>计数器法是限流算法里最简单也是最容易实现的一种算法。维护一个单位时间内的Counter，当单位时间已经过去则将Counter重置零。这个算法虽然简单，但是有一个十分致命的问题，那就是临界问题。在临界时间的前一毫秒和后一毫秒都触发了最大的请求数，就会在两毫秒内发生了两倍单位时间的最大请求数量。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>如果接触过TCP协议的话，那么一定对滑动窗口这个名词不会陌生。在时间窗划分多个格子，每个格子都单独维护一个Counter，窗口每次滑动一个格子。指定时间窗最大请求数，也就是限制的时间范围内允许的最大请求数。计数器算法其实就是滑动窗口算法，只是它没有对时间窗口做进一步地划分，所以只有1格。当维护当滑动窗口的格子划分的越多，限流就会越精确。可是这种方式没有完全解决临界问题，时间窗内一小段流量可能占比特别大。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>首先，我们有一个固定容量的桶，有水流进来，也有水流出去。对于流进来的水来说，我们无法预计一共有多少水会流进来，也无法预计水流的速度。但是对于流出去的水来说，这个桶可以固定水流出的速率。而且，当桶满了之后，多余的水将会溢出。该算法保证以一个常速速率来处理请求，所以不会出现临界问题。</p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>和漏桶算法效果类似但方向相反的算法。桶一开始是空的，token（令牌）以一个固定的速率r往桶里填充，直到达到桶的容量，多余的token将会被丢弃。每当一个请求过来时，就会尝试从桶里移除一个token，如果没有token的话，请求无法通过。令牌桶还可以方便的改变速度。 一旦需要提高速率,只要按需提高放入桶中的token的速率就行了。令牌桶算法允许流量一定程度的突发，取走token是不需要耗费时间的，也就是说，假设桶内有100个token时，那么可以瞬间允许100个请求通过。</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p>令牌桶算法由于实现简单，且允许某些流量的突发，对用户友好，所以被业界采用地较多。当然我们需要根据具体场景选择合适的算法。</p><h2 id="在go中的使用"><a href="#在go中的使用" class="headerlink" title="在go中的使用"></a>在go中的使用</h2><p><code>Go</code>提供了一个package(golang.org/x/time/rate)，采用令牌桶的算法实现，用来方便的对速度进行限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">limit Limit</span><br><span class="line">burst <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">mu     sync.Mutex</span><br><span class="line">tokens <span class="keyword">float64</span></span><br><span class="line">last time.Time</span><br><span class="line">lastEvent time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="keyword">int</span>)</span> *<span class="title">Limiter</span></span></span><br></pre></td></tr></table></figure><p>首先创建一个<code>rate.Limiter</code>，其有两个参数，第一个参数为允许每秒发生多少次事件，第二个参数是其缓存最大可存多少个事件。这个桶一开始容量为b，装满b个token，然后每秒往里面填充r个token。由于令牌桶中最多有b个token，所以一次最多只能允许b个事件发生，一个事件花费掉一个token。</p><p><code>rate.Limiter</code>提供三种主要的函数。</p><h3 id="Wait-WaitN"><a href="#Wait-WaitN" class="headerlink" title="Wait/WaitN"></a><code>Wait/WaitN</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Wait</span><span class="params">(ctx context.Context)</span> <span class="params">(err error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(lim *Limiter)</span> <span class="title">WaitN</span><span class="params">(ctx context.Context, n <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span></span><br></pre></td></tr></table></figure><p><code>Wait</code>是<code>WaitN(ctx, 1)</code>的简化形式。<code>WaitN</code>阻塞当前直到lim允许n个事件的发生。当没有可用或足够的事件时，将阻塞等待，推荐实际程序中使用这个方法。</p><h3 id="Allow-AllowN"><a href="#Allow-AllowN" class="headerlink" title="Allow/AllowN"></a><code>Allow/AllowN</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Allow</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(lim *Limiter)</span> <span class="title">AllowN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>Allow</code>是函数<code>AllowN(time.Now(), 1)</code>的简化函数。<code>AllowN</code>标识在时间<code>now</code>的时候，n个事件是否可以同时发生(也意思就是now的时候是否可以从令牌桶中取n个token)。适合在超出频率的时候丢弃或跳过事件的场景。</p><h3 id="Reserve-ReserveN"><a href="#Reserve-ReserveN" class="headerlink" title="Reserve/ReserveN"></a><code>Reserve/ReserveN</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Reserve</span><span class="params">()</span> *<span class="title">Reservation</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(lim *Limiter)</span> <span class="title">ReserveN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> *<span class="title">Reservation</span></span></span><br></pre></td></tr></table></figure><p><code>Reserve</code>是<code>ReserveN(time.Now(), 1)</code>的简化形式。<code>ReserveN</code>返回对象<code>Reservation</code>，用于标识调用者需要等多久才能等到n个事件发生(意思就是等多久令牌桶中至少含有n个token)。<code>Wait/WaitN</code>和<code>Allow/AllowN</code>其实就是基于其之上实现的，通过sleep等待时间和直接返回状态。如果想对事件发生的频率和等待处理逻辑更加精细的话就可以使用它。</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/time/rate"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">l := rate.NewLimiter(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">ctx := context.Background()</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="comment">// 要处理二十个事件</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">l.Wait(ctx)</span><br><span class="line"><span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(time.Since(start)) <span class="comment">// output: 7.501262697s （初始桶内5个和每秒2个token）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;限流是对资源访问进行控制，当访问超过承受范围的时候，我们就必须考虑限流来保证接口的可用性或者降级可用性。&lt;/p&gt;
&lt;h2 id=&quot;限流算法&quot;
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>尝鲜vgo</title>
    <link href="http://blog.keyboardman.me/2018/02/23/early-adopters-versioned-go/"/>
    <id>http://blog.keyboardman.me/2018/02/23/early-adopters-versioned-go/</id>
    <published>2018-02-23T08:18:16.000Z</published>
    <updated>2018-02-23T08:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，对go来说依赖包的版本控制上没有一个好的方案，当前主要有两种方式<code>Import Versioning</code>和<code>Semantic Versioning</code>。</p><ul><li>Import Versioning：<code>gopkg.in</code>网站，其实是GitHub版本变化的重定向器，你可以通过<code>gopkg.in/yaml.v1</code>和<code>gopkg.in/yaml.v2</code> 的这样的导入方式来指向Git库的不同提交版本</li><li>Semantic Versioning：制定了一个文件格式规范来描述管理vendor目录下代码的准确源和版本信息（dep、glide）</li></ul><p>前几天(2018-02-20)Russ Cox博客上介绍了他为go设计的新工具<code>vgo</code>，这是为处理软件包版本而设计的go工具的替代品，vgo即versioned go的缩写，意即带版本的go。vgo目前只能运行在go1.10之上，否则会得到<code>vgo objabi: cannot find GOMIPS</code>这样的错误。</p><p>首先安装vgo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u golang.org/x/vgo</span><br></pre></td></tr></table></figure><p>我们先尝试下，跟着<a href="https://research.swtch.com/vgo-tour" target="_blank" rel="noopener">官方示例</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="variable">$GOPATH</span>/src/hello</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/hello</span><br><span class="line">curl -sS https://swtch.com/hello.go &gt; hello.go</span><br></pre></td></tr></table></figure><p>我们看一下<code>hello.go</code>的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// import "github.com/you/hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"rsc.io/quote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(quote.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>// import &quot;github.com/you/hello&quot;</code>注释用来告诉vgo模块的“导入路径名称”应该是什么，并且使用此模块的其他软件包将用作导入标识符。<br>创建一个空的go.mod文件来标记此项目的根目录，然后编译一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &gt;go.mod</span><br><span class="line">vgo build</span><br></pre></td></tr></table></figure><p>可以看到生成可执行文件，并修改了<code>go.mod</code>的内容，自动生成了依赖关系。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module <span class="string">"github.com/you/hello"</span></span><br><span class="line"></span><br><span class="line">require <span class="string">"rsc.io/quote"</span> v1.<span class="number">5.2</span></span><br></pre></td></tr></table></figure><p><code>go.mod</code>文件包含了模块所依赖包的最小版本。如果模块没有提供一个<code>tag</code>版本。对于未命名的提交，<code>v0.0.0-yyyymmddhhmmss-commit</code>表示一个指定日期的提交。<code>go.mod</code>文件还可以实现排除和替换的版本，需手动修改<code>go.mod</code>文件。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exclude <span class="string">"rsc.io/sampler"</span> v1.<span class="number">99.99</span></span><br><span class="line"></span><br><span class="line">replace <span class="string">"rsc.io/quote"</span> v1.<span class="number">5.2</span> =&gt; <span class="string">"../quote"</span></span><br></pre></td></tr></table></figure><p>但是，最重要的变化还是终结了<code>GOPATH</code>作为Go代码工作空间的设置，由于<code>go.mod</code>文件包含了完整的模块路径并且还定义了每个使用的依赖的版本，因此包含<code>go.mod</code>文件的目录就可以被认为是一个目录树的根目录了，该目录树作用于自身的工作空间，并且和其他类似的目录彼此隔离。</p><p>vgo其他功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vgo list -m  <span class="comment"># 查看所有依赖</span></span><br><span class="line">vgo list -m -u  <span class="comment"># 查看所有依赖同时检查更新，会打印出最新版本和当前版本</span></span><br><span class="line">vgo <span class="built_in">test</span> all  <span class="comment"># 执行所有测试，包括依赖包的测试</span></span><br><span class="line">vgo <span class="built_in">test</span> http://rsc.io/sampler  <span class="comment"># 执行指定包测试</span></span><br><span class="line">vgo get -u  <span class="comment"># 更新所有依赖</span></span><br><span class="line">vgo list -t http://rsc.io/sampler  <span class="comment"># 检查指定包所有可用的版本 即tag</span></span><br><span class="line">vgo get http://rsc.io/sampler@v1.3.1  <span class="comment"># 获取指定版本，并修改go.mod</span></span><br><span class="line">vgo vendor  <span class="comment"># 退到vendor 兼容不使用vgo的用户</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>vgo在下载github仓库时，如果当前环境是未认证的账号会受到限流影响，得到如下警告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GitHub applies fairly small rate limits to unauthenticated users, and</span><br><span class="line">you appear to be hitting them. To authenticate, please visit</span><br><span class="line">https://github.com/settings/tokens and click <span class="string">"Generate New Token"</span> to</span><br><span class="line">create a Personal Access Token. The token only needs <span class="string">"public_repo"</span></span><br><span class="line">scope, but you can add <span class="string">"repo"</span> <span class="keyword">if</span> you want to access private</span><br><span class="line">repositories too.</span><br></pre></td></tr></table></figure><p>这时候需要获取github token，在github网站依次点击<code>Settings</code>-<code>Developer settings</code>-<code>Personal access tokens</code>-<code>Generate new token</code>，填写名字和勾选权限后生成token。创建或修改<code>$HOME/.netrc</code>文件，添加下行，把生成的token填写进去，就能解决了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine api.github.<span class="keyword">com</span> login YOU password TOKEN</span><br></pre></td></tr></table></figure><p>目前vgo的文档不够完善，代码也不够健壮，在生产环境可能还不适合去使用。我在测试时就遇到了些问题，比如有的<code>gopkg.in</code>仓库使用标签而不是分支来标记主要版本。当前vgo处理这些仓库会出错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"gopkg.in/natefinch/lumberjack.v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将得到如下错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"gopkg.in/natefinch/lumberjack.v2"</span>: unexpected status (https://api.github.com/repos/natefinch/lumberjack/commits?sha=v2&amp;until=2018-02-23T03%3A49%3A22Z&amp;per_page=2): 404 Not Found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">vgo: import <span class="string">"gopkg.in/natefinch/lumberjack.v2"</span>: unexpected status (https://api.github.com/repos/natefinch/lumberjack): 403 Forbidden</span><br></pre></td></tr></table></figure><p>不过vgo应该很快就会修复这些问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来，对go来说依赖包的版本控制上没有一个好的方案，当前主要有两种方式&lt;code&gt;Import Versioning&lt;/code&gt;和&lt;code&gt;Semantic Versioning&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Import Versioning：&lt;cod
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="vgo" scheme="http://blog.keyboardman.me/tags/vgo/"/>
    
  </entry>
  
  <entry>
    <title>在linux像脚本语言一样使用go</title>
    <link href="http://blog.keyboardman.me/2018/02/22/using-go-as-a-scripting-language-in-linux/"/>
    <id>http://blog.keyboardman.me/2018/02/22/using-go-as-a-scripting-language-in-linux/</id>
    <published>2018-02-22T03:16:24.000Z</published>
    <updated>2018-02-22T03:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们想使用go像脚本一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x script.go</span><br><span class="line">./script.go</span><br></pre></td></tr></table></figure><p>乍一看好像很容易实现，在<code>.go</code>文件开头添加shebang（<code>#!</code>）行就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env <span class="keyword">go</span> run</span><br></pre></td></tr></table></figure><p>但是这样运行时不能正确地将脚本错误码返回给操作系统。错误码这对于脚本来说很重要，因为错误代码是多个脚本之间相互交互和操作系统环境最常见的方式之一。</p><p>而<code>gorun</code>解决了这个问题，安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/erning/gorun</span><br><span class="line"></span><br><span class="line">cp <span class="variable">$GOPATH</span>/bin/gorun /usr/<span class="built_in">local</span>/bin  <span class="comment"># 非必要的，在注册binfmt_misc时使用gorun的绝对路径就行</span></span><br></pre></td></tr></table></figure><p>开头改成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env gorun</span><br></pre></td></tr></table></figure><p>可是还有个问题，因为Go不知道如何处理<code>#</code>开头的行。其他脚本语言没有这个问题，因为其中大多数<code>#</code>是一种指定注释的方式，但是Go注释以<code>//</code>开头，并且在调用<code>go run</code>或<code>go build</code>会产生错误。</p><p>我们中的大多数人都知道Linux（包括一些类Unix操作系统）的可执行文件是ELF二进制格式。其实Linux内核还支持更多二进制格式（用于各种二进制格式的树内模块通常在其名称中具有<code>binfmt_</code>前缀）。值得注意的是<code>binfmt_script</code>模块，它负责解析上面提到的seebang行并在目标系统上执行脚本。但shebang不是Go脚本的最佳选择，而Linux内核有一个合适的模块<code>binfmt_misc</code>。该模块可以通过定义良好的<code>procfs</code>接口直接从用户空间动态添加对各种可执行格式的支持。</p><p>根据<a href="https://www.kernel.org/doc/html/v4.14/admin-guide/binfmt-misc.html" target="_blank" rel="noopener">内核文档</a>，首先安装<code>binfmt_misc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc</span><br></pre></td></tr></table></figure><p>现在我们需要告诉<code>binfmt_misc</code>模块如何使用<code>gorun</code>来执行我们的<code>.go</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">':golang:E::go::/usr/local/bin/gorun:OC'</span> | sudo tee /proc/sys/fs/binfmt_misc/register</span><br></pre></td></tr></table></figure><p>配置字符串<code>:golang:E::go::/usr/local/bin/gorun:OC</code>，它告诉系统：“如果遇到一个带<code>.go</code>扩展名的可执行文件，请使用<code>/usr/local/bin/gorun</code>解释器执行它“。字符串末尾的OC标志确保脚本将根据脚本本身设置的所有者信息和权限位执行，而不是在解释器二进制文件上设置的那些位。这使Go脚本的执行行为与Linux中其他可执行文件和脚本的行为相同。这并没有改变<code>.go</code>文件的内容，自然可以像之前一样的<code>go run</code>和<code>go build</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时我们想使用go像脚本一样。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="go技巧" scheme="http://blog.keyboardman.me/categories/go%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="linux" scheme="http://blog.keyboardman.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-连接语义和API</title>
    <link href="http://blog.keyboardman.me/2018/02/08/grpc-doc-with-grpc-connectivity-semantics-and-api/"/>
    <id>http://blog.keyboardman.me/2018/02/08/grpc-doc-with-grpc-connectivity-semantics-and-api/</id>
    <published>2018-02-08T08:51:12.000Z</published>
    <updated>2018-03-13T13:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md" target="_blank" rel="noopener">gRPC Connectivity Semantics and API</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/connectivity-semantics-and-api.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>本文档描述了gRPC通道的连接语义以及对RPC的相应影响。然后我们浅谈下API。</p><h3 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h3><p>gRPC抽象了客户端与服务器进行通信的方式。客户端通道对象可以使用多于一个DNS名称来创建。通道封装了一系列功能，包括名称解析，建立TCP连接(带有retry和backoff)以及TLS握手。通道还可以处理已建立的连接上的错误并重新连接，或者在HTTP/2 <code>GO_AWAY</code>的情况下，重新解析并重新连接。</p><p>为了对使用者隐藏gRPC API(即程序代码)的这些活动的细节，同时暴露有关信道状态的有意义的信息，用具有五种状态的状态机表示，定义如下：</p><p>CONNECTING: 该通道正在尝试建立连接，正在等待名称解析，TCP连接建立或TLS握手所涉及的其中一个步骤。这可以被用作创建时的通道的初始状态。</p><p>READY: 通道已经通过TLS握手(或相当的操作)后一直成功地建立连接，并且所有后续的通信尝试都成功(或者正在等待而没有任何已知的故障)。</p><p>TRANSIENT_FAILURE: 出现了一些暂时的故障(如TCP三次握手超时或socket错误)。此状态下的通道最终将切换到<code>CONNECTING</code>状态，并尝试再次建立连接。由于重试是以指数backoff的方式完成的，所以不能连接的信道将在这个状态下花费很少的时间，但是由于尝试重复失败，信道将花费越来越多的时间在这个状态。对于许多非致命故障(例如，由于服务器尚不可用而导致TCP连接尝试超时)，信道可能在此状态下花费越来越多的时间。</p><p>IDLE: 这是由于缺乏新的或待处理的RPC，通道甚至不尝试创建连接的状态。新的RPC可以在这个状态下创建。任何尝试在通道上启动RPC都会将通道的状态变更为CONNECTING。当一个指定<code>IDLE_TIMEOUT</code>的通道上没有RPC活动时，即在此期间没有新的或挂起的（活动）RPC时，<code>READY</code>或<code>CONNECTING</code>通道状态变更为<code>IDLE</code>。另外，当没有活动或待处理的RPC时，接收<code>GOAWAY</code>的通道也应变更到IDLE状态，以避免试图断开连接的服务器的连接超载。我们将使用300秒(5分钟)的默认<code>IDLE_TIMEOUT</code>。</p><p>SHUTDOWN: 这个通道已经开始关闭了。任何新的RPC应该立即失败。待处理的RPC可能会继续运行，直到程序取消它们。通道可能会进入此状态，因为程序明确要求关闭或在尝试连接通信期间发生了不可恢复的错误(截至2015年12月6日，没有已知的错误(连接或通信中)被归类为不可恢复)。 进入此状态的通道永远不会改变这个状态。</p><p>下表列出了从一个状态到另一个状态的转换规则以及相应的原因。<code>-</code>单元格表示不允许的转换。</p><table><thead><tr><th>From/To</th><th style="text-align:center">CONNECTING</th><th style="text-align:center">READY</th><th style="text-align:center">TRANSIENT_FAILURE</th><th style="text-align:center">IDLE</th><th style="text-align:center">SHUTDOWN</th></tr></thead><tbody><tr><td>CONNECTING</td><td style="text-align:center">在连接建立期间增量</td><td style="text-align:center">建立连接所需的所有步骤都成功了</td><td style="text-align:center">在建立连接所需的任何步骤中出现任何故障</td><td style="text-align:center">通道上没有RPC活动直到<code>IDLE_TIMEOUT</code></td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>READY</td><td style="text-align:center">-</td><td style="text-align:center">在已建立的通道上增加成功的通话</td><td style="text-align:center">预期在已建立的通道上成功通信时遇到任何故障</td><td style="text-align:center">没有活动或待处理的RPC时接收<code>GOAWAY</code>或没有待处理的RPC直到<code>IDLE_TIMEOUT</code></td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>TRANSIENT_FAILURE</td><td style="text-align:center">指数backoff重试等待时间结束</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>IDLE</td><td style="text-align:center">频道上的任何新的RPC活动</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>SHUTDOWN</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><h3 id="通道状态API"><a href="#通道状态API" class="headerlink" title="通道状态API"></a>通道状态API</h3><p>所有的gRPC库都会公开一个通道级别的API方法来轮询当前的通道状态。在C++中，这种方法称为<code>GetState</code>，并返回五个合法状态之一的枚举。如果通道当前是IDLE的，它也接受布尔<code>try_to_connect</code>转换到CONNECTING，他的行为像一个RPC发生，所以它也应该重置<code>IDLE_TIMEOUT</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">grpc_connectivity_state <span class="title">GetState</span><span class="params">(<span class="keyword">bool</span> try_to_connect)</span></span>;</span><br></pre></td></tr></table></figure></p><p>所有的库都应该公开一个API，使得程序(gRPC API的使用者)在通道状态改变时得到通知。由于状态变化可以很快并且与任何这样的通知竞争，所以通知应该只是通知使用者已经发生了一些状态改变，留给使用者轮询当前状态。</p><p>这个API的同步版本是:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WaitForStateChange</span><span class="params">(grpc_connectivity_state source_state, gpr_timespec deadline)</span></span>;</span><br></pre></td></tr></table></figure></p><p>当状态是<code>source_state</code>以外的状态时返回true，如果截止时间到期则返回false。基于异步和期货的API应该有一个相应的方法，允许在通道状态改变时通知程序。</p><p>请注意，每次从任何状态转换到其他任何状态时都会发送通知。另一方面，合法状态转换的规则，即使相应的指数回退在重试之前不需要等待，也需要从连接转换到<code>TRANSIENT_FAILURE</code>，并返回连接到每个可恢复故障。综合的影响是应用程序可能会收到虚假的状态更改通知。例如，在<code>CONNECTING</code>状态的通道上等待状态改变的应用程序可以接收状态改变通知，但是在轮询当前状态时找到处于还是<code>CONNECTING</code>状态的通道，因为该通道可能在<code>TRANSIENT_FAILURE</code>状态中花费了无限小的时间量。</p><hr><h2 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h2><p>go的实现基本同上，除了去掉了<code>try_to_connect</code>的功能。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">connectivity</span>.<span class="title">State</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cc.csMgr.getState()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">WaitForStateChange</span><span class="params">(ctx context.Context, sourceState connectivity.State)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ch := cc.csMgr.getNotifyChan()</span><br><span class="line"><span class="keyword">if</span> cc.csMgr.getState() != sourceState &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真正的功能实现在<code>connectivityStateManager</code>中。可以看到<code>ClientConn.WaitForStateChange</code>是通过新建或监听已有<code>notifyChan</code>来感知状态变化。而修改状态的函数<code>updateState</code>在修改状态后，关闭<code>notifyChan</code>来通知所有监听goroutine状态变更。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> connectivityStateManager <span class="keyword">struct</span> &#123;</span><br><span class="line">mu         sync.Mutex</span><br><span class="line">state      connectivity.State</span><br><span class="line">notifyChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">updateState</span><span class="params">(state connectivity.State)</span></span> &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> csm.state == connectivity.Shutdown &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> csm.state == state &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">csm.state = state</span><br><span class="line"><span class="keyword">if</span> csm.notifyChan != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(csm.notifyChan)</span><br><span class="line">csm.notifyChan = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">connectivity</span>.<span class="title">State</span></span> &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> csm.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">getNotifyChan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> csm.notifyChan == <span class="literal">nil</span> &#123;</span><br><span class="line">csm.notifyChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> csm.notifyChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在连接<code>connect</code>时会创建一个goroutine去监控状态变化，通过<code>handleSubConnStateChange</code>(最终调用到<code>connectivityStateManager.updateState</code>)去修改状态。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ac *addrConn)</span> <span class="title">transportMonitor</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> timer *time.Timer</span><br><span class="line"><span class="keyword">var</span> cdeadline &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">ac.mu.Lock()</span><br><span class="line">t := ac.transport</span><br><span class="line"><span class="comment">// 如果有设置截止时间则生成个定时器</span></span><br><span class="line"><span class="keyword">if</span> !ac.connectDeadline.IsZero() &#123;</span><br><span class="line">timer = time.NewTimer(ac.connectDeadline.Sub(time.Now()))</span><br><span class="line">cdeadline = timer.C</span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="comment">// 阻塞，直到我们收到`GoAway`或发生错误</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.GoAway(): <span class="comment">// GoAway</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.Error():  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cdeadline:  <span class="comment">// 超时</span></span><br><span class="line">ac.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> ac.backoffDeadline.IsZero() &#123;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line">timer = <span class="literal">nil</span></span><br><span class="line">grpclog.Warningf(<span class="string">"grpc: addrConn.transportMonitor didn't get server preface after waiting. Closing the new transport now."</span>)</span><br><span class="line">t.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> timer != <span class="literal">nil</span> &#123;</span><br><span class="line">timer.Stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果GoAway发生了，不管错误如何，适当调整我们的Keepalive参数</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.GoAway():</span><br><span class="line">ac.adjustParams(t.GetGoAwayReason())</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> ac.state == connectivity.Shutdown &#123;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在调用resetTransport之前，将连接状态设置为TransientFailure。因为无法从READY变成CONNECTING。</span></span><br><span class="line">ac.state = connectivity.TransientFailure</span><br><span class="line">ac.cc.handleSubConnStateChange(ac.acbw, ac.state)</span><br><span class="line">ac.cc.resolveNow(resolver.ResolveNowOption&#123;&#125;)</span><br><span class="line">ac.curAddr = resolver.Address&#123;&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="comment">// resetTransport将重新创建连接，把状态设置为Connecting</span></span><br><span class="line"><span class="keyword">if</span> err := ac.resetTransport(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ac.mu.Lock()</span><br><span class="line">ac.printf(<span class="string">"transport exiting: %v"</span>, err)</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line">grpclog.Warningf(<span class="string">"grpc: addrConn.transportMonitor exits due to: %v"</span>, err)</span><br><span class="line"><span class="keyword">if</span> err != errConnClosing &#123;</span><br><span class="line">ac.tearDown(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遇到错误或手动调用<code>Close</code>时，将状态设置为<code>Shutdown</code>，相关goroutine感知到状态为<code>Shutdown</code>或得到<code>errConnClosing</code>错误时自己退出。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p><p>虽然有<code>Idle</code>状态，但是却没有和doc<code>IDLE_TIMEOUT</code>和相关的实现。目前只作为负载均衡中一些连接状态的标记。</p><p>当我们想要判断一个连接是不是可用(<code>Ready</code>)状态时，可以：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">s := cc.GetState()</span><br><span class="line"><span class="keyword">if</span> s == connectivity.Ready &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !cc.WaitForStateChange(ctx, s) &#123;</span><br><span class="line"><span class="comment">// ctx got timeout or canceled.</span></span><br><span class="line"><span class="comment">// handle timeout</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;g
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-连接backoff协议</title>
    <link href="http://blog.keyboardman.me/2018/02/06/grpc-doc-with-grpc-connection-backoff/"/>
    <id>http://blog.keyboardman.me/2018/02/06/grpc-doc-with-grpc-connection-backoff/</id>
    <published>2018-02-06T02:21:01.000Z</published>
    <updated>2018-03-13T13:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md" target="_blank" rel="noopener">gRPC Connection Backoff Protocol</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/connection-backoff.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>当我们连接到一个失败的后端时，通常希望不要立即重试(以避免泛滥的网络或服务器的请求)，而是做某种形式的指数backoff。</p><p>我们有几个参数：</p><ol><li>INITIAL_BACKOFF (第一次失败重试前后需等待多久)</li><li>MULTIPLIER (在失败的重试后乘以的倍数)</li><li>JITTER (随机抖动因子).</li><li>MAX_BACKOFF (backoff上限)</li><li>MIN_CONNECT_TIMEOUT (最短重试间隔)</li></ol><h3 id="建议backoff算法"><a href="#建议backoff算法" class="headerlink" title="建议backoff算法"></a>建议backoff算法</h3><p>以指数形式返回连接尝试的起始时间，达到MAX_BACKOFF的极限，并带有抖动。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectWithBackoff()</span><br><span class="line">  current_backoff = INITIAL_BACKOFF</span><br><span class="line">  current_deadline = now() + INITIAL_BACKOFF</span><br><span class="line">  <span class="keyword">while</span> (TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT))!= SUCCESS)</span><br><span class="line">    SleepUntil(current_deadline)</span><br><span class="line">    current_backoff = Min(current_backoff * MULTIPLIER, MAX_BACKOFF)</span><br><span class="line">    current_deadline = now() + current_backoff + UniformRandom(-JITTER * current_backoff, JITTER * current_backoff)</span><br></pre></td></tr></table></figure></p><p>参数默认值<code>MIN_CONNECT_TIMEOUT</code>=20sec <code>INITIAL_BACKOFF</code>=1sec <code>MULTIPLIER</code>=1.6 <code>MAX_BACKOFF</code>=120sec <code>JITTER</code>=0.2</p><p>根据的确切的关注点实现(例如最小化手机的唤醒次数)可能希望使用不同的算法，特别是不同的抖动逻辑。</p><p>备用的实现必须确保连接退避在同一时间开始分散，并且不得比上述算法更频繁地尝试连接。</p><h3 id="重置backoff"><a href="#重置backoff" class="headerlink" title="重置backoff"></a>重置backoff</h3><p>backoff应在某个时间点重置为<code>INITIAL_BACKOFF</code>，以便重新连接行为是一致的，不管连接的是新开始的还是先前断开的连接。</p><p>当接收到<code>SETTINGS</code>帧时重置backoff，在那个时候，我们确定这个连接被服务器已经接受了。</p><hr><h2 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h2><p>源码位于<code>google.golang.org/grpc/backoff</code>，代码不多，直接在代码上分析。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应上面的默认值但是没有实现MIN_CONNECT_TIMEOUT参数</span></span><br><span class="line"><span class="keyword">var</span> DefaultBackoffConfig = BackoffConfig&#123;</span><br><span class="line">MaxDelay:  <span class="number">120</span> * time.Second,</span><br><span class="line">baseDelay: <span class="number">1.0</span> * time.Second,</span><br><span class="line">factor:    <span class="number">1.6</span>,</span><br><span class="line">jitter:    <span class="number">0.2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backoffStrategy是backoff算法的接口</span></span><br><span class="line"><span class="keyword">type</span> backoffStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过重试次数返回在下一次重试之前等待的时间量</span></span><br><span class="line">backoff(retries <span class="keyword">int</span>) time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BackoffConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">MaxDelay time.Duration</span><br><span class="line">baseDelay time.Duration</span><br><span class="line">factor <span class="keyword">float64</span></span><br><span class="line">jitter <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDefaults</span><span class="params">(bc *BackoffConfig)</span></span> &#123;</span><br><span class="line">md := bc.MaxDelay</span><br><span class="line">*bc = DefaultBackoffConfig</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> md &gt; <span class="number">0</span> &#123;</span><br><span class="line">bc.MaxDelay = md</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backoff算法的基础实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc BackoffConfig)</span> <span class="title">backoff</span><span class="params">(retries <span class="keyword">int</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> retries == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bc.baseDelay</span><br><span class="line">&#125;</span><br><span class="line">backoff, max := <span class="keyword">float64</span>(bc.baseDelay), <span class="keyword">float64</span>(bc.MaxDelay)</span><br><span class="line"><span class="keyword">for</span> backoff &lt; max &amp;&amp; retries &gt; <span class="number">0</span> &#123;</span><br><span class="line">backoff *= bc.factor</span><br><span class="line">retries--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> backoff &gt; max &#123;</span><br><span class="line">backoff = max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Randomize backoff delays so that if a cluster of requests start at</span></span><br><span class="line"><span class="comment">// the same time, they won't operate in lockstep.</span></span><br><span class="line">backoff *= <span class="number">1</span> + bc.jitter*(rand.Float64()*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> backoff &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> time.Duration(backoff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果默认的backoff算法不满足需求的时候，还可以自定义backoff算法，通过实现backoffStrategy接口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withBackoff</span><span class="params">(bs backoffStrategy)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.bs = bs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grpc.Dial(addr, grpc.withBackoff(mybackoff))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC Connecti
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-健康检查</title>
    <link href="http://blog.keyboardman.me/2018/02/05/grpc-doc-with-grpc-go-health-checking/"/>
    <id>http://blog.keyboardman.me/2018/02/05/grpc-doc-with-grpc-go-health-checking/</id>
    <published>2018-02-05T09:24:22.000Z</published>
    <updated>2018-03-13T13:40:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">gRPC Health Checking Protocol</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/health-checking.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>健康检查用于探测服务器是否能够处理rpc。client到server的健康状况检查可能会发生在点对点或通过某个控制系统。server可能会选择回复“不健康”，因为它没有准备好接受请求，正在关闭或其他原因。如果在一段时间内没有收到回复，或者回复内容不健康，client可以采取相应措施。</p><p>使用gRPC service作为对client到server简单场景和其他控制系统(负载均衡)的健康检查机制。作为一个高层次的service带来一些好处。首先，由于它本身是一个gRPC service，所以进行健康检查的形式与正常的rpc相同。其次，它具有丰富的语义，如每个service的健康状况。第三，作为gRPC服务，它可以重用所有现有的如计费和限制基础设施等，因此server可以完全控制健康检查service的访问。</p><h3 id="Service定义"><a href="#Service定义" class="headerlink" title="Service定义"></a>Service定义</h3><p>server由下面的proto中service定义导出：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  string service = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    SERVING = 1;</span><br><span class="line">    NOT_SERVING = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client可以通过调用<code>Check</code>方法来查询service的健康状态，并且应该在rpc上设置超时。client可以选择设置要查询健康状态的服务名称。建议的服务名称格式是<code>package_names.ServiceName</code>，比如<code>grpc.health.v1.Health</code>。</p><p>这个server应手动注册所有的service并设置各自的状态，包括空服务名称及其状态。对于收到的每个请求，如果可以在注册表中找到服务名称，则必须以<code>OK</code>状态发回响应，并且相应地将状态字段设置为<code>SERVING</code>或<code>NOT_SERVING</code>。如果服务名称未注册，则服务器返回<code>NOT_FOUND</code> GRPC状态。</p><p>server应该使用一个空字符串作为server的整体运行状况的关键字，以便对特定service不感兴趣的client可以用空请求查询服务器的状态。server可以在不支持任何通配符匹配的情况下完成对service名称的精确匹配。但是，service所有者可以自由地实现对client和server一致更复杂的匹配语义。</p><p>client如果rpc一段时间后没有完成可以宣布server不健康。client应该能够处理server没有<code>Health</code> service的情况。</p><hr><h2 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h2><p><code>grpc-go</code>本身就有实现这个server，我们可以很方便的嵌入到我们的grpc服务中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line">healthpb <span class="string">"google.golang.org/grpc/health/grpc_health_v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">pb.RegisterMyServer(s, &amp;myServer&#123;&#125;)</span><br><span class="line"><span class="comment">// add </span></span><br><span class="line">hsrv := health.NewServer()</span><br><span class="line">hsrv.SetServingStatus(<span class="string">""</span>, healthpb.HealthCheckResponse_SERVING)</span><br><span class="line">healthpb.RegisterHealthServer(s, hsrv)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>client部分跟所有正常grpc请求一样，编写下测试代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cli := healthpb.NewHealthClient(grpcConn)</span><br><span class="line">resp, err := cli.Check(context.TODO(), &amp;healthpb.HealthCheckRequest&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.Status != healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很简单就嵌入了健康检查的功能，当然client对状态的判断处理要根据实际场景情况进行相应的处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC Health Chec
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>Functional Options Patter</title>
    <link href="http://blog.keyboardman.me/2018/01/03/grpc-functional-options-patter/"/>
    <id>http://blog.keyboardman.me/2018/01/03/grpc-functional-options-patter/</id>
    <published>2018-01-03T07:57:25.000Z</published>
    <updated>2018-03-13T13:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方式都用不了。</p><p>像构造方法这是一个非常常见的用例，拿它来做例子。比方说,我们有一些名为<code>Client</code>的结构,它有一个连接和附属参数(timeout和retries)，然后我们提供一个构造方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">interface</span> &#123;</span><br><span class="line">    Do() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> client <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    Connection</span><br><span class="line">    timeout <span class="keyword">int</span></span><br><span class="line">    retries <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">Client</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;client&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: timeout,</span><br><span class="line">        retries: retries,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是每次调用NewClient时都要提供<code>timeout</code>和<code>retries</code>。而大多数时候只想使用默认值。<br>一个方法是创建另一个不同名称的构造方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection)</span> <span class="title">Client</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewClientWithOptions</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">Client</span></span></span><br></pre></td></tr></table></figure></p><p>另一种是传入了一个配置对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    Retries <span class="keyword">int</span> </span><br><span class="line">    Timeout <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection, options Options)</span> <span class="title">Client</span></span></span><br></pre></td></tr></table></figure></p><p>不够优雅，要么要写非常多的构造方法，要么需要在代码中进行额外的检查和验证或通过传递不关心的参数来为做额外判断的工作。而grpc使用的是一种干净的解决方案: Functional Options Patter。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dialOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">insecure    <span class="keyword">bool</span></span><br><span class="line">timeout     time.Duration</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DialOption <span class="function"><span class="keyword">func</span><span class="params">(*dialOptions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ClientConn</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">dopts        dialOptions</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(*ClientConn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> DialContext(context.Background(), target, opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ClientConn</code>主要附属参数在<code>dopts</code>中，构造方法<code>Dial</code>参数是可选个数的<code>DialOption</code>。是不是觉得和上面第二种没什么区别，注意传进去的<code>DialOption</code>是方法，先看看库里几个常见的方法的实现。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithInsecure</span><span class="params">()</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.insecure = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(d time.Duration)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.timeout = d</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>dialOptions</code>是可用选项，定义了一些方法<code>WithInsecure</code>和<code>WithTimeout</code>, 它们返回一个闭包函数，用来修改<code>dialOptions</code>的选项。 另外又定义了<code>DialOption</code>, 它是一个接受这些方法。接着我们来看构造方法的关键部分。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">cc := &amp;ClientConn&#123;</span><br><span class="line">target: target,</span><br><span class="line">csMgr:  &amp;connectivityStateManager&#123;&#125;,</span><br><span class="line">conns:  <span class="built_in">make</span>(<span class="keyword">map</span>[*addrConn]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line"></span><br><span class="line">blockingpicker: newPickerWrapper(),</span><br><span class="line">&#125;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// 如果想设置默认值可以 cc.dopts = DefaultDopts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(&amp;cc.dopts)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造函数遍历了DialOption列表, 并对每一项应用返回的闭包运用到的选项<code>dopts</code>。使用起来也很方便。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grpc.Dial(addr, grpc.WithInsecure())</span><br><span class="line">grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(time.Duration(<span class="number">10</span>*time.Second)))</span><br></pre></td></tr></table></figure></p><p>而且我们可以随时添加新的选项, 只需要对代码进行非常少量的更改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方
      
    
    </summary>
    
      <category term="grpc-go源码分析" scheme="http://blog.keyboardman.me/categories/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="源码分析" scheme="http://blog.keyboardman.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
