<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>keyboardman</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.keyboardman.me/"/>
  <updated>2018-02-08T09:09:26.000Z</updated>
  <id>http://blog.keyboardman.me/</id>
  
  <author>
    <name>0x5010</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>grpc-go-连接语义和API</title>
    <link href="http://blog.keyboardman.me/2018/02/08/grpc-doc-with-grpc-connectivity-semantics-and-api/"/>
    <id>http://blog.keyboardman.me/2018/02/08/grpc-doc-with-grpc-connectivity-semantics-and-api/</id>
    <published>2018-02-08T08:51:12.000Z</published>
    <updated>2018-02-08T09:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md" target="_blank" rel="noopener">gRPC Connectivity Semantics and API</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/connectivity-semantics-and-api.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h1 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h1><p>本文档描述了gRPC通道的连接语义以及对RPC的相应影响。然后我们浅谈下API。</p><h2 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h2><p>gRPC抽象了客户端与服务器进行通信的方式。客户端通道对象可以使用多于一个DNS名称来创建。通道封装了一系列功能，包括名称解析，建立TCP连接(带有retry和backoff)以及TLS握手。通道还可以处理已建立的连接上的错误并重新连接，或者在HTTP/2 <code>GO_AWAY</code>的情况下，重新解析并重新连接。</p><p>为了对使用者隐藏gRPC API(即程序代码)的这些活动的细节，同时暴露有关信道状态的有意义的信息，用具有五种状态的状态机表示，定义如下：</p><p>CONNECTING: 该通道正在尝试建立连接，正在等待名称解析，TCP连接建立或TLS握手所涉及的其中一个步骤。这可以被用作创建时的通道的初始状态。</p><p>READY: 通道已经通过TLS握手(或相当的操作)后一直成功地建立连接，并且所有后续的通信尝试都成功(或者正在等待而没有任何已知的故障)。</p><p>TRANSIENT_FAILURE: 出现了一些暂时的故障(如TCP三次握手超时或socket错误)。此状态下的通道最终将切换到<code>CONNECTING</code>状态，并尝试再次建立连接。由于重试是以指数backoff的方式完成的，所以不能连接的信道将在这个状态下花费很少的时间，但是由于尝试重复失败，信道将花费越来越多的时间在这个状态。对于许多非致命故障(例如，由于服务器尚不可用而导致TCP连接尝试超时)，信道可能在此状态下花费越来越多的时间。</p><p>IDLE: 这是由于缺乏新的或待处理的RPC，通道甚至不尝试创建连接的状态。新的RPC可以在这个状态下创建。任何尝试在通道上启动RPC都会将通道的状态变更为CONNECTING。当一个指定<code>IDLE_TIMEOUT</code>的通道上没有RPC活动时，即在此期间没有新的或挂起的（活动）RPC时，<code>READY</code>或<code>CONNECTING</code>通道状态变更为<code>IDLE</code>。另外，当没有活动或待处理的RPC时，接收<code>GOAWAY</code>的通道也应变更到IDLE状态，以避免试图断开连接的服务器的连接超载。我们将使用300秒(5分钟)的默认<code>IDLE_TIMEOUT</code>。</p><p>SHUTDOWN: 这个通道已经开始关闭了。任何新的RPC应该立即失败。待处理的RPC可能会继续运行，直到程序取消它们。通道可能会进入此状态，因为程序明确要求关闭或在尝试连接通信期间发生了不可恢复的错误(截至2015年12月6日，没有已知的错误(连接或通信中)被归类为不可恢复)。 进入此状态的通道永远不会改变这个状态。</p><p>下表列出了从一个状态到另一个状态的转换规则以及相应的原因。<code>-</code>单元格表示不允许的转换。</p><table><thead><tr><th>From/To</th><th style="text-align:center">CONNECTING</th><th style="text-align:center">READY</th><th style="text-align:center">TRANSIENT_FAILURE</th><th style="text-align:center">IDLE</th><th style="text-align:center">SHUTDOWN</th></tr></thead><tbody><tr><td>CONNECTING</td><td style="text-align:center">在连接建立期间增量</td><td style="text-align:center">建立连接所需的所有步骤都成功了</td><td style="text-align:center">在建立连接所需的任何步骤中出现任何故障</td><td style="text-align:center">通道上没有RPC活动直到<code>IDLE_TIMEOUT</code></td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>READY</td><td style="text-align:center">-</td><td style="text-align:center">在已建立的通道上增加成功的通话</td><td style="text-align:center">预期在已建立的通道上成功通信时遇到任何故障</td><td style="text-align:center">没有活动或待处理的RPC时接收<code>GOAWAY</code>或没有待处理的RPC直到<code>IDLE_TIMEOUT</code></td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>TRANSIENT_FAILURE</td><td style="text-align:center">指数backoff重试等待时间结束</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>IDLE</td><td style="text-align:center">频道上的任何新的RPC活动</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">程序触发shutdown</td></tr><tr><td>SHUTDOWN</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="通道状态API"><a href="#通道状态API" class="headerlink" title="通道状态API"></a>通道状态API</h2><p>所有的gRPC库都会公开一个通道级别的API方法来轮询当前的通道状态。在C++中，这种方法称为<code>GetState</code>，并返回五个合法状态之一的枚举。如果通道当前是IDLE的，它也接受布尔<code>try_to_connect</code>转换到CONNECTING，他的行为像一个RPC发生，所以它也应该重置<code>IDLE_TIMEOUT</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">grpc_connectivity_state <span class="title">GetState</span><span class="params">(<span class="keyword">bool</span> try_to_connect)</span></span>;</span><br></pre></td></tr></table></figure></p><p>所有的库都应该公开一个API，使得程序(gRPC API的使用者)在通道状态改变时得到通知。由于状态变化可以很快并且与任何这样的通知竞争，所以通知应该只是通知使用者已经发生了一些状态改变，留给使用者轮询当前状态。</p><p>这个API的同步版本是:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WaitForStateChange</span><span class="params">(grpc_connectivity_state source_state, gpr_timespec deadline)</span></span>;</span><br></pre></td></tr></table></figure></p><p>当状态是<code>source_state</code>以外的状态时返回true，如果截止时间到期则返回false。基于异步和期货的API应该有一个相应的方法，允许在通道状态改变时通知程序。</p><p>请注意，每次从任何状态转换到其他任何状态时都会发送通知。另一方面，合法状态转换的规则，即使相应的指数回退在重试之前不需要等待，也需要从连接转换到<code>TRANSIENT_FAILURE</code>，并返回连接到每个可恢复故障。综合的影响是应用程序可能会收到虚假的状态更改通知。例如，在<code>CONNECTING</code>状态的通道上等待状态改变的应用程序可以接收状态改变通知，但是在轮询当前状态时找到处于还是<code>CONNECTING</code>状态的通道，因为该通道可能在<code>TRANSIENT_FAILURE</code>状态中花费了无限小的时间量。</p><hr><h1 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h1><p>go的实现基本同上，除了去掉了<code>try_to_connect</code>的功能。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">GetState</span><span class="params">()</span> <span class="title">connectivity</span>.<span class="title">State</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cc.csMgr.getState()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">WaitForStateChange</span><span class="params">(ctx context.Context, sourceState connectivity.State)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ch := cc.csMgr.getNotifyChan()</span><br><span class="line"><span class="keyword">if</span> cc.csMgr.getState() != sourceState &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真正的功能实现在<code>connectivityStateManager</code>中。可以看到<code>ClientConn.WaitForStateChange</code>是通过新建或监听已有<code>notifyChan</code>来感知状态变化。而修改状态的函数<code>updateState</code>在修改状态后，关闭<code>notifyChan</code>来通知所有监听goroutine状态变更。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> connectivityStateManager <span class="keyword">struct</span> &#123;</span><br><span class="line">mu         sync.Mutex</span><br><span class="line">state      connectivity.State</span><br><span class="line">notifyChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">updateState</span><span class="params">(state connectivity.State)</span></span> &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> csm.state == connectivity.Shutdown &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> csm.state == state &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">csm.state = state</span><br><span class="line"><span class="keyword">if</span> csm.notifyChan != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(csm.notifyChan)</span><br><span class="line">csm.notifyChan = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">connectivity</span>.<span class="title">State</span></span> &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> csm.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(csm *connectivityStateManager)</span> <span class="title">getNotifyChan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">csm.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> csm.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> csm.notifyChan == <span class="literal">nil</span> &#123;</span><br><span class="line">csm.notifyChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> csm.notifyChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在连接<code>connect</code>时会创建一个goroutine去监控状态变化，通过<code>handleSubConnStateChange</code>(最终调用到<code>connectivityStateManager.updateState</code>)去修改状态。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ac *addrConn)</span> <span class="title">transportMonitor</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> timer *time.Timer</span><br><span class="line"><span class="keyword">var</span> cdeadline &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">ac.mu.Lock()</span><br><span class="line">t := ac.transport</span><br><span class="line"><span class="comment">// 如果有设置截止时间则生成个定时器</span></span><br><span class="line"><span class="keyword">if</span> !ac.connectDeadline.IsZero() &#123;</span><br><span class="line">timer = time.NewTimer(ac.connectDeadline.Sub(time.Now()))</span><br><span class="line">cdeadline = timer.C</span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="comment">// 阻塞，直到我们收到`GoAway`或发生错误</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.GoAway(): <span class="comment">// GoAway</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.Error():  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cdeadline:  <span class="comment">// 超时</span></span><br><span class="line">ac.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> ac.backoffDeadline.IsZero() &#123;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line">timer = <span class="literal">nil</span></span><br><span class="line">grpclog.Warningf(<span class="string">"grpc: addrConn.transportMonitor didn't get server preface after waiting. Closing the new transport now."</span>)</span><br><span class="line">t.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> timer != <span class="literal">nil</span> &#123;</span><br><span class="line">timer.Stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果GoAway发生了，不管错误如何，适当调整我们的Keepalive参数</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.GoAway():</span><br><span class="line">ac.adjustParams(t.GetGoAwayReason())</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">ac.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> ac.state == connectivity.Shutdown &#123;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在调用resetTransport之前，将连接状态设置为TransientFailure。因为无法从READY变成CONNECTING。</span></span><br><span class="line">ac.state = connectivity.TransientFailure</span><br><span class="line">ac.cc.handleSubConnStateChange(ac.acbw, ac.state)</span><br><span class="line">ac.cc.resolveNow(resolver.ResolveNowOption&#123;&#125;)</span><br><span class="line">ac.curAddr = resolver.Address&#123;&#125;</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line"><span class="comment">// resetTransport将重新创建连接，把状态设置为Connecting</span></span><br><span class="line"><span class="keyword">if</span> err := ac.resetTransport(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ac.mu.Lock()</span><br><span class="line">ac.printf(<span class="string">"transport exiting: %v"</span>, err)</span><br><span class="line">ac.mu.Unlock()</span><br><span class="line">grpclog.Warningf(<span class="string">"grpc: addrConn.transportMonitor exits due to: %v"</span>, err)</span><br><span class="line"><span class="keyword">if</span> err != errConnClosing &#123;</span><br><span class="line">ac.tearDown(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遇到错误或手动调用<code>Close</code>时，将状态设置为<code>Shutdown</code>，相关goroutine感知到状态为<code>Shutdown</code>或得到<code>errConnClosing</code>错误时自己退出。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cc *ClientConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p><p>虽然有<code>Idle</code>状态，但是却没有和doc<code>IDLE_TIMEOUT</code>和相关的实现。目前只作为负载均衡中一些连接状态的标记。</p><p>当我们想要判断一个连接是不是可用(<code>Ready</code>)状态时，可以：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">s := cc.GetState()</span><br><span class="line"><span class="keyword">if</span> s == connectivity.Ready &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !cc.WaitForStateChange(ctx, s) &#123;</span><br><span class="line"><span class="comment">// ctx got timeout or canceled.</span></span><br><span class="line"><span class="comment">// handle timeout</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/connectivity-semantics-and-api.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;g
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-连接backoff协议</title>
    <link href="http://blog.keyboardman.me/2018/02/06/grpc-doc-with-grpc-connection-backoff/"/>
    <id>http://blog.keyboardman.me/2018/02/06/grpc-doc-with-grpc-connection-backoff/</id>
    <published>2018-02-06T02:21:01.000Z</published>
    <updated>2018-02-06T02:21:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md" target="_blank" rel="noopener">gRPC Connection Backoff Protocol</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/connection-backoff.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h1 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h1><p>当我们连接到一个失败的后端时，通常希望不要立即重试(以避免泛滥的网络或服务器的请求)，而是做某种形式的指数backoff。</p><p>我们有几个参数：</p><ol><li>INITIAL_BACKOFF (第一次失败重试前后需等待多久)</li><li>MULTIPLIER (在失败的重试后乘以的倍数)</li><li>JITTER (随机抖动因子).</li><li>MAX_BACKOFF (backoff上限)</li><li>MIN_CONNECT_TIMEOUT (最短重试间隔)</li></ol><h2 id="建议backoff算法"><a href="#建议backoff算法" class="headerlink" title="建议backoff算法"></a>建议backoff算法</h2><p>以指数形式返回连接尝试的起始时间，达到MAX_BACKOFF的极限，并带有抖动。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectWithBackoff()</span><br><span class="line">  current_backoff = INITIAL_BACKOFF</span><br><span class="line">  current_deadline = now() + INITIAL_BACKOFF</span><br><span class="line">  <span class="keyword">while</span> (TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT))!= SUCCESS)</span><br><span class="line">    SleepUntil(current_deadline)</span><br><span class="line">    current_backoff = Min(current_backoff * MULTIPLIER, MAX_BACKOFF)</span><br><span class="line">    current_deadline = now() + current_backoff + UniformRandom(-JITTER * current_backoff, JITTER * current_backoff)</span><br></pre></td></tr></table></figure></p><p>参数默认值<code>MIN_CONNECT_TIMEOUT</code>=20sec <code>INITIAL_BACKOFF</code>=1sec <code>MULTIPLIER</code>=1.6 <code>MAX_BACKOFF</code>=120sec <code>JITTER</code>=0.2</p><p>根据的确切的关注点实现(例如最小化手机的唤醒次数)可能希望使用不同的算法，特别是不同的抖动逻辑。</p><p>备用的实现必须确保连接退避在同一时间开始分散，并且不得比上述算法更频繁地尝试连接。</p><h2 id="重置backoff"><a href="#重置backoff" class="headerlink" title="重置backoff"></a>重置backoff</h2><p>backoff应在某个时间点重置为<code>INITIAL_BACKOFF</code>，以便重新连接行为是一致的，不管连接的是新开始的还是先前断开的连接。</p><p>当接收到<code>SETTINGS</code>帧时重置backoff，在那个时候，我们确定这个连接被服务器已经接受了。</p><hr><h1 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h1><p>源码位于<code>google.golang.org/grpc/backoff</code>，代码不多，直接在代码上分析。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应上面的默认值但是没有实现MIN_CONNECT_TIMEOUT参数</span></span><br><span class="line"><span class="keyword">var</span> DefaultBackoffConfig = BackoffConfig&#123;</span><br><span class="line">MaxDelay:  <span class="number">120</span> * time.Second,</span><br><span class="line">baseDelay: <span class="number">1.0</span> * time.Second,</span><br><span class="line">factor:    <span class="number">1.6</span>,</span><br><span class="line">jitter:    <span class="number">0.2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backoffStrategy是backoff算法的接口</span></span><br><span class="line"><span class="keyword">type</span> backoffStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过重试次数返回在下一次重试之前等待的时间量</span></span><br><span class="line">backoff(retries <span class="keyword">int</span>) time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BackoffConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">MaxDelay time.Duration</span><br><span class="line">baseDelay time.Duration</span><br><span class="line">factor <span class="keyword">float64</span></span><br><span class="line">jitter <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDefaults</span><span class="params">(bc *BackoffConfig)</span></span> &#123;</span><br><span class="line">md := bc.MaxDelay</span><br><span class="line">*bc = DefaultBackoffConfig</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> md &gt; <span class="number">0</span> &#123;</span><br><span class="line">bc.MaxDelay = md</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backoff算法的基础实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc BackoffConfig)</span> <span class="title">backoff</span><span class="params">(retries <span class="keyword">int</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> retries == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bc.baseDelay</span><br><span class="line">&#125;</span><br><span class="line">backoff, max := <span class="keyword">float64</span>(bc.baseDelay), <span class="keyword">float64</span>(bc.MaxDelay)</span><br><span class="line"><span class="keyword">for</span> backoff &lt; max &amp;&amp; retries &gt; <span class="number">0</span> &#123;</span><br><span class="line">backoff *= bc.factor</span><br><span class="line">retries--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> backoff &gt; max &#123;</span><br><span class="line">backoff = max</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Randomize backoff delays so that if a cluster of requests start at</span></span><br><span class="line"><span class="comment">// the same time, they won't operate in lockstep.</span></span><br><span class="line">backoff *= <span class="number">1</span> + bc.jitter*(rand.Float64()*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> backoff &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> time.Duration(backoff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果默认的backoff算法不满足需求的时候，还可以自定义backoff算法，通过实现backoffStrategy接口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withBackoff</span><span class="params">(bs backoffStrategy)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.bs = bs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grpc.Dial(addr, grpc.withBackoff(mybackoff))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC Connecti
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>grpc-go-健康检查</title>
    <link href="http://blog.keyboardman.me/2018/02/05/grpc-doc-with-grpc-go-health-checking/"/>
    <id>http://blog.keyboardman.me/2018/02/05/grpc-doc-with-grpc-go-health-checking/</id>
    <published>2018-02-05T09:24:22.000Z</published>
    <updated>2018-02-05T09:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener">gRPC Health Checking Protocol</a><br>译文：<a href="https://0x5010.gitbooks.io/grpc-doc-zh/content/health-checking.html" target="_blank" rel="noopener">gitbook</a><br>译者：<a href="https://github.com/0x5010" target="_blank" rel="noopener">0x5010</a></p></blockquote><h1 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h1><p>健康检查用于探测服务器是否能够处理rpc。client到server的健康状况检查可能会发生在点对点或通过某个控制系统。server可能会选择回复“不健康”，因为它没有准备好接受请求，正在关闭或其他原因。如果在一段时间内没有收到回复，或者回复内容不健康，client可以采取相应措施。</p><p>使用gRPC service作为对client到server简单场景和其他控制系统(负载均衡)的健康检查机制。作为一个高层次的service带来一些好处。首先，由于它本身是一个gRPC service，所以进行健康检查的形式与正常的rpc相同。其次，它具有丰富的语义，如每个service的健康状况。第三，作为gRPC服务，它可以重用所有现有的如计费和限制基础设施等，因此server可以完全控制健康检查service的访问。</p><h2 id="Service定义"><a href="#Service定义" class="headerlink" title="Service定义"></a>Service定义</h2><p>server由下面的proto中service定义导出：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package grpc.health.v1;</span><br><span class="line"></span><br><span class="line">message HealthCheckRequest &#123;</span><br><span class="line">  string service = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HealthCheckResponse &#123;</span><br><span class="line">  enum ServingStatus &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    SERVING = 1;</span><br><span class="line">    NOT_SERVING = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  ServingStatus status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Health &#123;</span><br><span class="line">  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client可以通过调用<code>Check</code>方法来查询service的健康状态，并且应该在rpc上设置超时。client可以选择设置要查询健康状态的服务名称。建议的服务名称格式是<code>package_names.ServiceName</code>，比如<code>grpc.health.v1.Health</code>。</p><p>这个server应手动注册所有的service并设置各自的状态，包括空服务名称及其状态。对于收到的每个请求，如果可以在注册表中找到服务名称，则必须以<code>OK</code>状态发回响应，并且相应地将状态字段设置为<code>SERVING</code>或<code>NOT_SERVING</code>。如果服务名称未注册，则服务器返回<code>NOT_FOUND</code> GRPC状态。</p><p>server应该使用一个空字符串作为server的整体运行状况的关键字，以便对特定service不感兴趣的client可以用空请求查询服务器的状态。server可以在不支持任何通配符匹配的情况下完成对service名称的精确匹配。但是，service所有者可以自由地实现对client和server一致更复杂的匹配语义。</p><p>client如果rpc一段时间后没有完成可以宣布server不健康。client应该能够处理server没有<code>Health</code> service的情况。</p><hr><h1 id="grpc-go"><a href="#grpc-go" class="headerlink" title="grpc-go"></a>grpc-go</h1><p><code>grpc-go</code>本身就有实现这个server，我们可以很方便的嵌入到我们的grpc服务中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line">healthpb <span class="string">"google.golang.org/grpc/health/grpc_health_v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line">pb.RegisterMyServer(s, &amp;myServer&#123;&#125;)</span><br><span class="line"><span class="comment">// add </span></span><br><span class="line">hsrv := health.NewServer()</span><br><span class="line">hsrv.SetServingStatus(<span class="string">""</span>, healthpb.HealthCheckResponse_SERVING)</span><br><span class="line">healthpb.RegisterHealthServer(s, hsrv)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>client部分跟所有正常grpc请求一样，编写下测试代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cli := healthpb.NewHealthClient(grpcConn)</span><br><span class="line">resp, err := cli.Check(context.TODO(), &amp;healthpb.HealthCheckRequest&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.Status != healthpb.HealthCheckResponse_SERVING &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很简单就嵌入了健康检查的功能，当然client对状态的判断处理要根据实际场景情况进行相应的处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/grpc/grpc/blob/master/doc/health-checking.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC Health Chec
      
    
    </summary>
    
      <category term="grpc doc与grpc-go的实现" scheme="http://blog.keyboardman.me/categories/grpc-doc%E4%B8%8Egrpc-go%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="doc" scheme="http://blog.keyboardman.me/tags/doc/"/>
    
  </entry>
  
  <entry>
    <title>Functional Options Patter</title>
    <link href="http://blog.keyboardman.me/2018/01/03/grpc-functional-options-patter/"/>
    <id>http://blog.keyboardman.me/2018/01/03/grpc-functional-options-patter/</id>
    <published>2018-01-03T07:57:25.000Z</published>
    <updated>2018-02-05T09:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方式都用不了。</p><p>像构造方法这是一个非常常见的用例，拿它来做例子。比方说,我们有一些名为<code>Client</code>的结构,它有一个连接和附属参数(timeout和retries)，然后我们提供一个构造方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">interface</span> &#123;</span><br><span class="line">    Do() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> client <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    Connection</span><br><span class="line">    timeout <span class="keyword">int</span></span><br><span class="line">    retries <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">Client</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;client&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: timeout,</span><br><span class="line">        retries: retries,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是每次调用NewClient时都要提供<code>timeout</code>和<code>retries</code>。而大多数时候只想使用默认值。<br>一个方法是创建另一个不同名称的构造方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection)</span> <span class="title">Client</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewClientWithOptions</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">Client</span></span></span><br></pre></td></tr></table></figure></p><p>另一种是传入了一个配置对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">    Retries <span class="keyword">int</span> </span><br><span class="line">    Timeout <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn Connection, options Options)</span> <span class="title">Client</span></span></span><br></pre></td></tr></table></figure></p><p>不够优雅，要么要写非常多的构造方法，要么需要在代码中进行额外的检查和验证或通过传递不关心的参数来为做额外判断的工作。而grpc使用的是一种干净的解决方案: Functional Options Patter。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dialOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">insecure    <span class="keyword">bool</span></span><br><span class="line">timeout     time.Duration</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DialOption <span class="function"><span class="keyword">func</span><span class="params">(*dialOptions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ClientConn</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">dopts        dialOptions</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(*ClientConn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> DialContext(context.Background(), target, opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ClientConn</code>主要附属参数在<code>dopts</code>中，构造方法<code>Dial</code>参数是可选个数的<code>DialOption</code>。是不是觉得和上面第二种没什么区别，注意传进去的<code>DialOption</code>是方法，先看看库里几个常见的方法的实现。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithInsecure</span><span class="params">()</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.insecure = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(d time.Duration)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">o.timeout = d</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>dialOptions</code>是可用选项，定义了一些方法<code>WithInsecure</code>和<code>WithTimeout</code>, 它们返回一个闭包函数，用来修改<code>dialOptions</code>的选项。 另外又定义了<code>DialOption</code>, 它是一个接受这些方法。接着我们来看构造方法的关键部分。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</span><br><span class="line">cc := &amp;ClientConn&#123;</span><br><span class="line">target: target,</span><br><span class="line">csMgr:  &amp;connectivityStateManager&#123;&#125;,</span><br><span class="line">conns:  <span class="built_in">make</span>(<span class="keyword">map</span>[*addrConn]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line"></span><br><span class="line">blockingpicker: newPickerWrapper(),</span><br><span class="line">&#125;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// 如果想设置默认值可以 cc.dopts = DefaultDopts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">opt(&amp;cc.dopts)</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造函数遍历了DialOption列表, 并对每一项应用返回的闭包运用到的选项<code>dopts</code>。使用起来也很方便。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grpc.Dial(addr, grpc.WithInsecure())</span><br><span class="line">grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(time.Duration(<span class="number">10</span>*time.Second)))</span><br></pre></td></tr></table></figure></p><p>而且我们可以随时添加新的选项, 只需要对代码进行非常少量的更改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中，经常会将一个方法的参数设置为可选，并设置一些默认值，使代码更通用简洁。在很多语言中这很容易，比如在C类语言中,可以使用相同方法名不同参数的多个版本(重写)， 而在像python这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们。但是在 Go中, 这两种方
      
    
    </summary>
    
      <category term="grpc-go源码分析" scheme="http://blog.keyboardman.me/categories/grpc-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="go" scheme="http://blog.keyboardman.me/tags/go/"/>
    
      <category term="grpc" scheme="http://blog.keyboardman.me/tags/grpc/"/>
    
      <category term="源码分析" scheme="http://blog.keyboardman.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
